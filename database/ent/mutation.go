// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/DemoonLXW/up_learning/database/ent/class"
	"github.com/DemoonLXW/up_learning/database/ent/college"
	"github.com/DemoonLXW/up_learning/database/ent/file"
	"github.com/DemoonLXW/up_learning/database/ent/major"
	"github.com/DemoonLXW/up_learning/database/ent/menu"
	"github.com/DemoonLXW/up_learning/database/ent/permission"
	"github.com/DemoonLXW/up_learning/database/ent/predicate"
	"github.com/DemoonLXW/up_learning/database/ent/project"
	"github.com/DemoonLXW/up_learning/database/ent/projectfile"
	"github.com/DemoonLXW/up_learning/database/ent/reviewproject"
	"github.com/DemoonLXW/up_learning/database/ent/reviewprojectdetail"
	"github.com/DemoonLXW/up_learning/database/ent/role"
	"github.com/DemoonLXW/up_learning/database/ent/rolepermission"
	"github.com/DemoonLXW/up_learning/database/ent/samplefile"
	"github.com/DemoonLXW/up_learning/database/ent/school"
	"github.com/DemoonLXW/up_learning/database/ent/student"
	"github.com/DemoonLXW/up_learning/database/ent/teacher"
	"github.com/DemoonLXW/up_learning/database/ent/user"
	"github.com/DemoonLXW/up_learning/database/ent/userrole"
	"github.com/DemoonLXW/up_learning/entity"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeClass               = "Class"
	TypeCollege             = "College"
	TypeFile                = "File"
	TypeMajor               = "Major"
	TypeMenu                = "Menu"
	TypePermission          = "Permission"
	TypeProject             = "Project"
	TypeProjectFile         = "ProjectFile"
	TypeReviewProject       = "ReviewProject"
	TypeReviewProjectDetail = "ReviewProjectDetail"
	TypeRole                = "Role"
	TypeRolePermission      = "RolePermission"
	TypeSampleFile          = "SampleFile"
	TypeSchool              = "School"
	TypeStudent             = "Student"
	TypeTeacher             = "Teacher"
	TypeUser                = "User"
	TypeUserRole            = "UserRole"
)

// ClassMutation represents an operation that mutates the Class nodes in the graph.
type ClassMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	grade           *string
	name            *string
	is_disabled     *bool
	created_time    *time.Time
	deleted_time    *time.Time
	modified_time   *time.Time
	clearedFields   map[string]struct{}
	major           *uint16
	clearedmajor    bool
	students        map[uint32]struct{}
	removedstudents map[uint32]struct{}
	clearedstudents bool
	done            bool
	oldValue        func(context.Context) (*Class, error)
	predicates      []predicate.Class
}

var _ ent.Mutation = (*ClassMutation)(nil)

// classOption allows management of the mutation configuration using functional options.
type classOption func(*ClassMutation)

// newClassMutation creates new mutation for the Class entity.
func newClassMutation(c config, op Op, opts ...classOption) *ClassMutation {
	m := &ClassMutation{
		config:        c,
		op:            op,
		typ:           TypeClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassID sets the ID field of the mutation.
func withClassID(id uint32) classOption {
	return func(m *ClassMutation) {
		var (
			err   error
			once  sync.Once
			value *Class
		)
		m.oldValue = func(ctx context.Context) (*Class, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Class.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClass sets the old Class of the mutation.
func withClass(node *Class) classOption {
	return func(m *ClassMutation) {
		m.oldValue = func(context.Context) (*Class, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Class entities.
func (m *ClassMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClassMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClassMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Class.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMid sets the "mid" field.
func (m *ClassMutation) SetMid(u uint16) {
	m.major = &u
}

// Mid returns the value of the "mid" field in the mutation.
func (m *ClassMutation) Mid() (r uint16, exists bool) {
	v := m.major
	if v == nil {
		return
	}
	return *v, true
}

// OldMid returns the old "mid" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldMid(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMid: %w", err)
	}
	return oldValue.Mid, nil
}

// ResetMid resets all changes to the "mid" field.
func (m *ClassMutation) ResetMid() {
	m.major = nil
}

// SetGrade sets the "grade" field.
func (m *ClassMutation) SetGrade(s string) {
	m.grade = &s
}

// Grade returns the value of the "grade" field in the mutation.
func (m *ClassMutation) Grade() (r string, exists bool) {
	v := m.grade
	if v == nil {
		return
	}
	return *v, true
}

// OldGrade returns the old "grade" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldGrade(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrade is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrade requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrade: %w", err)
	}
	return oldValue.Grade, nil
}

// ResetGrade resets all changes to the "grade" field.
func (m *ClassMutation) ResetGrade() {
	m.grade = nil
}

// SetName sets the "name" field.
func (m *ClassMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ClassMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ClassMutation) ResetName() {
	m.name = nil
}

// SetIsDisabled sets the "is_disabled" field.
func (m *ClassMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *ClassMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *ClassMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *ClassMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *ClassMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *ClassMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *ClassMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *ClassMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldDeletedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ClearDeletedTime clears the value of the "deleted_time" field.
func (m *ClassMutation) ClearDeletedTime() {
	m.deleted_time = nil
	m.clearedFields[class.FieldDeletedTime] = struct{}{}
}

// DeletedTimeCleared returns if the "deleted_time" field was cleared in this mutation.
func (m *ClassMutation) DeletedTimeCleared() bool {
	_, ok := m.clearedFields[class.FieldDeletedTime]
	return ok
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *ClassMutation) ResetDeletedTime() {
	m.deleted_time = nil
	delete(m.clearedFields, class.FieldDeletedTime)
}

// SetModifiedTime sets the "modified_time" field.
func (m *ClassMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *ClassMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldModifiedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ClearModifiedTime clears the value of the "modified_time" field.
func (m *ClassMutation) ClearModifiedTime() {
	m.modified_time = nil
	m.clearedFields[class.FieldModifiedTime] = struct{}{}
}

// ModifiedTimeCleared returns if the "modified_time" field was cleared in this mutation.
func (m *ClassMutation) ModifiedTimeCleared() bool {
	_, ok := m.clearedFields[class.FieldModifiedTime]
	return ok
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *ClassMutation) ResetModifiedTime() {
	m.modified_time = nil
	delete(m.clearedFields, class.FieldModifiedTime)
}

// SetMajorID sets the "major" edge to the Major entity by id.
func (m *ClassMutation) SetMajorID(id uint16) {
	m.major = &id
}

// ClearMajor clears the "major" edge to the Major entity.
func (m *ClassMutation) ClearMajor() {
	m.clearedmajor = true
}

// MajorCleared reports if the "major" edge to the Major entity was cleared.
func (m *ClassMutation) MajorCleared() bool {
	return m.clearedmajor
}

// MajorID returns the "major" edge ID in the mutation.
func (m *ClassMutation) MajorID() (id uint16, exists bool) {
	if m.major != nil {
		return *m.major, true
	}
	return
}

// MajorIDs returns the "major" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MajorID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) MajorIDs() (ids []uint16) {
	if id := m.major; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMajor resets all changes to the "major" edge.
func (m *ClassMutation) ResetMajor() {
	m.major = nil
	m.clearedmajor = false
}

// AddStudentIDs adds the "students" edge to the Student entity by ids.
func (m *ClassMutation) AddStudentIDs(ids ...uint32) {
	if m.students == nil {
		m.students = make(map[uint32]struct{})
	}
	for i := range ids {
		m.students[ids[i]] = struct{}{}
	}
}

// ClearStudents clears the "students" edge to the Student entity.
func (m *ClassMutation) ClearStudents() {
	m.clearedstudents = true
}

// StudentsCleared reports if the "students" edge to the Student entity was cleared.
func (m *ClassMutation) StudentsCleared() bool {
	return m.clearedstudents
}

// RemoveStudentIDs removes the "students" edge to the Student entity by IDs.
func (m *ClassMutation) RemoveStudentIDs(ids ...uint32) {
	if m.removedstudents == nil {
		m.removedstudents = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.students, ids[i])
		m.removedstudents[ids[i]] = struct{}{}
	}
}

// RemovedStudents returns the removed IDs of the "students" edge to the Student entity.
func (m *ClassMutation) RemovedStudentsIDs() (ids []uint32) {
	for id := range m.removedstudents {
		ids = append(ids, id)
	}
	return
}

// StudentsIDs returns the "students" edge IDs in the mutation.
func (m *ClassMutation) StudentsIDs() (ids []uint32) {
	for id := range m.students {
		ids = append(ids, id)
	}
	return
}

// ResetStudents resets all changes to the "students" edge.
func (m *ClassMutation) ResetStudents() {
	m.students = nil
	m.clearedstudents = false
	m.removedstudents = nil
}

// Where appends a list predicates to the ClassMutation builder.
func (m *ClassMutation) Where(ps ...predicate.Class) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClassMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClassMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Class, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClassMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClassMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Class).
func (m *ClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClassMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.major != nil {
		fields = append(fields, class.FieldMid)
	}
	if m.grade != nil {
		fields = append(fields, class.FieldGrade)
	}
	if m.name != nil {
		fields = append(fields, class.FieldName)
	}
	if m.is_disabled != nil {
		fields = append(fields, class.FieldIsDisabled)
	}
	if m.created_time != nil {
		fields = append(fields, class.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, class.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, class.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case class.FieldMid:
		return m.Mid()
	case class.FieldGrade:
		return m.Grade()
	case class.FieldName:
		return m.Name()
	case class.FieldIsDisabled:
		return m.IsDisabled()
	case class.FieldCreatedTime:
		return m.CreatedTime()
	case class.FieldDeletedTime:
		return m.DeletedTime()
	case class.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case class.FieldMid:
		return m.OldMid(ctx)
	case class.FieldGrade:
		return m.OldGrade(ctx)
	case class.FieldName:
		return m.OldName(ctx)
	case class.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case class.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case class.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case class.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Class field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case class.FieldMid:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMid(v)
		return nil
	case class.FieldGrade:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrade(v)
		return nil
	case class.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case class.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case class.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case class.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case class.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClassMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClassMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Class numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClassMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(class.FieldDeletedTime) {
		fields = append(fields, class.FieldDeletedTime)
	}
	if m.FieldCleared(class.FieldModifiedTime) {
		fields = append(fields, class.FieldModifiedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassMutation) ClearField(name string) error {
	switch name {
	case class.FieldDeletedTime:
		m.ClearDeletedTime()
		return nil
	case class.FieldModifiedTime:
		m.ClearModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown Class nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClassMutation) ResetField(name string) error {
	switch name {
	case class.FieldMid:
		m.ResetMid()
		return nil
	case class.FieldGrade:
		m.ResetGrade()
		return nil
	case class.FieldName:
		m.ResetName()
		return nil
	case class.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case class.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case class.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case class.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.major != nil {
		edges = append(edges, class.EdgeMajor)
	}
	if m.students != nil {
		edges = append(edges, class.EdgeStudents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case class.EdgeMajor:
		if id := m.major; id != nil {
			return []ent.Value{*id}
		}
	case class.EdgeStudents:
		ids := make([]ent.Value, 0, len(m.students))
		for id := range m.students {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedstudents != nil {
		edges = append(edges, class.EdgeStudents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClassMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case class.EdgeStudents:
		ids := make([]ent.Value, 0, len(m.removedstudents))
		for id := range m.removedstudents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmajor {
		edges = append(edges, class.EdgeMajor)
	}
	if m.clearedstudents {
		edges = append(edges, class.EdgeStudents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClassMutation) EdgeCleared(name string) bool {
	switch name {
	case class.EdgeMajor:
		return m.clearedmajor
	case class.EdgeStudents:
		return m.clearedstudents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClassMutation) ClearEdge(name string) error {
	switch name {
	case class.EdgeMajor:
		m.ClearMajor()
		return nil
	}
	return fmt.Errorf("unknown Class unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClassMutation) ResetEdge(name string) error {
	switch name {
	case class.EdgeMajor:
		m.ResetMajor()
		return nil
	case class.EdgeStudents:
		m.ResetStudents()
		return nil
	}
	return fmt.Errorf("unknown Class edge %s", name)
}

// CollegeMutation represents an operation that mutates the College nodes in the graph.
type CollegeMutation struct {
	config
	op              Op
	typ             string
	id              *uint8
	name            *string
	is_disabled     *bool
	created_time    *time.Time
	deleted_time    *time.Time
	modified_time   *time.Time
	clearedFields   map[string]struct{}
	majors          map[uint16]struct{}
	removedmajors   map[uint16]struct{}
	clearedmajors   bool
	teachers        map[uint32]struct{}
	removedteachers map[uint32]struct{}
	clearedteachers bool
	done            bool
	oldValue        func(context.Context) (*College, error)
	predicates      []predicate.College
}

var _ ent.Mutation = (*CollegeMutation)(nil)

// collegeOption allows management of the mutation configuration using functional options.
type collegeOption func(*CollegeMutation)

// newCollegeMutation creates new mutation for the College entity.
func newCollegeMutation(c config, op Op, opts ...collegeOption) *CollegeMutation {
	m := &CollegeMutation{
		config:        c,
		op:            op,
		typ:           TypeCollege,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCollegeID sets the ID field of the mutation.
func withCollegeID(id uint8) collegeOption {
	return func(m *CollegeMutation) {
		var (
			err   error
			once  sync.Once
			value *College
		)
		m.oldValue = func(ctx context.Context) (*College, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().College.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCollege sets the old College of the mutation.
func withCollege(node *College) collegeOption {
	return func(m *CollegeMutation) {
		m.oldValue = func(context.Context) (*College, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CollegeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CollegeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of College entities.
func (m *CollegeMutation) SetID(id uint8) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CollegeMutation) ID() (id uint8, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CollegeMutation) IDs(ctx context.Context) ([]uint8, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint8{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().College.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CollegeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CollegeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the College entity.
// If the College object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollegeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CollegeMutation) ResetName() {
	m.name = nil
}

// SetIsDisabled sets the "is_disabled" field.
func (m *CollegeMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *CollegeMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the College entity.
// If the College object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollegeMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *CollegeMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *CollegeMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *CollegeMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the College entity.
// If the College object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollegeMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *CollegeMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *CollegeMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *CollegeMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the College entity.
// If the College object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollegeMutation) OldDeletedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ClearDeletedTime clears the value of the "deleted_time" field.
func (m *CollegeMutation) ClearDeletedTime() {
	m.deleted_time = nil
	m.clearedFields[college.FieldDeletedTime] = struct{}{}
}

// DeletedTimeCleared returns if the "deleted_time" field was cleared in this mutation.
func (m *CollegeMutation) DeletedTimeCleared() bool {
	_, ok := m.clearedFields[college.FieldDeletedTime]
	return ok
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *CollegeMutation) ResetDeletedTime() {
	m.deleted_time = nil
	delete(m.clearedFields, college.FieldDeletedTime)
}

// SetModifiedTime sets the "modified_time" field.
func (m *CollegeMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *CollegeMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the College entity.
// If the College object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollegeMutation) OldModifiedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ClearModifiedTime clears the value of the "modified_time" field.
func (m *CollegeMutation) ClearModifiedTime() {
	m.modified_time = nil
	m.clearedFields[college.FieldModifiedTime] = struct{}{}
}

// ModifiedTimeCleared returns if the "modified_time" field was cleared in this mutation.
func (m *CollegeMutation) ModifiedTimeCleared() bool {
	_, ok := m.clearedFields[college.FieldModifiedTime]
	return ok
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *CollegeMutation) ResetModifiedTime() {
	m.modified_time = nil
	delete(m.clearedFields, college.FieldModifiedTime)
}

// AddMajorIDs adds the "majors" edge to the Major entity by ids.
func (m *CollegeMutation) AddMajorIDs(ids ...uint16) {
	if m.majors == nil {
		m.majors = make(map[uint16]struct{})
	}
	for i := range ids {
		m.majors[ids[i]] = struct{}{}
	}
}

// ClearMajors clears the "majors" edge to the Major entity.
func (m *CollegeMutation) ClearMajors() {
	m.clearedmajors = true
}

// MajorsCleared reports if the "majors" edge to the Major entity was cleared.
func (m *CollegeMutation) MajorsCleared() bool {
	return m.clearedmajors
}

// RemoveMajorIDs removes the "majors" edge to the Major entity by IDs.
func (m *CollegeMutation) RemoveMajorIDs(ids ...uint16) {
	if m.removedmajors == nil {
		m.removedmajors = make(map[uint16]struct{})
	}
	for i := range ids {
		delete(m.majors, ids[i])
		m.removedmajors[ids[i]] = struct{}{}
	}
}

// RemovedMajors returns the removed IDs of the "majors" edge to the Major entity.
func (m *CollegeMutation) RemovedMajorsIDs() (ids []uint16) {
	for id := range m.removedmajors {
		ids = append(ids, id)
	}
	return
}

// MajorsIDs returns the "majors" edge IDs in the mutation.
func (m *CollegeMutation) MajorsIDs() (ids []uint16) {
	for id := range m.majors {
		ids = append(ids, id)
	}
	return
}

// ResetMajors resets all changes to the "majors" edge.
func (m *CollegeMutation) ResetMajors() {
	m.majors = nil
	m.clearedmajors = false
	m.removedmajors = nil
}

// AddTeacherIDs adds the "teachers" edge to the Teacher entity by ids.
func (m *CollegeMutation) AddTeacherIDs(ids ...uint32) {
	if m.teachers == nil {
		m.teachers = make(map[uint32]struct{})
	}
	for i := range ids {
		m.teachers[ids[i]] = struct{}{}
	}
}

// ClearTeachers clears the "teachers" edge to the Teacher entity.
func (m *CollegeMutation) ClearTeachers() {
	m.clearedteachers = true
}

// TeachersCleared reports if the "teachers" edge to the Teacher entity was cleared.
func (m *CollegeMutation) TeachersCleared() bool {
	return m.clearedteachers
}

// RemoveTeacherIDs removes the "teachers" edge to the Teacher entity by IDs.
func (m *CollegeMutation) RemoveTeacherIDs(ids ...uint32) {
	if m.removedteachers == nil {
		m.removedteachers = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.teachers, ids[i])
		m.removedteachers[ids[i]] = struct{}{}
	}
}

// RemovedTeachers returns the removed IDs of the "teachers" edge to the Teacher entity.
func (m *CollegeMutation) RemovedTeachersIDs() (ids []uint32) {
	for id := range m.removedteachers {
		ids = append(ids, id)
	}
	return
}

// TeachersIDs returns the "teachers" edge IDs in the mutation.
func (m *CollegeMutation) TeachersIDs() (ids []uint32) {
	for id := range m.teachers {
		ids = append(ids, id)
	}
	return
}

// ResetTeachers resets all changes to the "teachers" edge.
func (m *CollegeMutation) ResetTeachers() {
	m.teachers = nil
	m.clearedteachers = false
	m.removedteachers = nil
}

// Where appends a list predicates to the CollegeMutation builder.
func (m *CollegeMutation) Where(ps ...predicate.College) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CollegeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CollegeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.College, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CollegeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CollegeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (College).
func (m *CollegeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CollegeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, college.FieldName)
	}
	if m.is_disabled != nil {
		fields = append(fields, college.FieldIsDisabled)
	}
	if m.created_time != nil {
		fields = append(fields, college.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, college.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, college.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CollegeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case college.FieldName:
		return m.Name()
	case college.FieldIsDisabled:
		return m.IsDisabled()
	case college.FieldCreatedTime:
		return m.CreatedTime()
	case college.FieldDeletedTime:
		return m.DeletedTime()
	case college.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CollegeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case college.FieldName:
		return m.OldName(ctx)
	case college.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case college.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case college.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case college.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown College field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollegeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case college.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case college.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case college.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case college.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case college.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown College field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CollegeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CollegeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollegeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown College numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CollegeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(college.FieldDeletedTime) {
		fields = append(fields, college.FieldDeletedTime)
	}
	if m.FieldCleared(college.FieldModifiedTime) {
		fields = append(fields, college.FieldModifiedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CollegeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CollegeMutation) ClearField(name string) error {
	switch name {
	case college.FieldDeletedTime:
		m.ClearDeletedTime()
		return nil
	case college.FieldModifiedTime:
		m.ClearModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown College nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CollegeMutation) ResetField(name string) error {
	switch name {
	case college.FieldName:
		m.ResetName()
		return nil
	case college.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case college.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case college.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case college.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown College field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CollegeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.majors != nil {
		edges = append(edges, college.EdgeMajors)
	}
	if m.teachers != nil {
		edges = append(edges, college.EdgeTeachers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CollegeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case college.EdgeMajors:
		ids := make([]ent.Value, 0, len(m.majors))
		for id := range m.majors {
			ids = append(ids, id)
		}
		return ids
	case college.EdgeTeachers:
		ids := make([]ent.Value, 0, len(m.teachers))
		for id := range m.teachers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CollegeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmajors != nil {
		edges = append(edges, college.EdgeMajors)
	}
	if m.removedteachers != nil {
		edges = append(edges, college.EdgeTeachers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CollegeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case college.EdgeMajors:
		ids := make([]ent.Value, 0, len(m.removedmajors))
		for id := range m.removedmajors {
			ids = append(ids, id)
		}
		return ids
	case college.EdgeTeachers:
		ids := make([]ent.Value, 0, len(m.removedteachers))
		for id := range m.removedteachers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CollegeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmajors {
		edges = append(edges, college.EdgeMajors)
	}
	if m.clearedteachers {
		edges = append(edges, college.EdgeTeachers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CollegeMutation) EdgeCleared(name string) bool {
	switch name {
	case college.EdgeMajors:
		return m.clearedmajors
	case college.EdgeTeachers:
		return m.clearedteachers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CollegeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown College unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CollegeMutation) ResetEdge(name string) error {
	switch name {
	case college.EdgeMajors:
		m.ResetMajors()
		return nil
	case college.EdgeTeachers:
		m.ResetTeachers()
		return nil
	}
	return fmt.Errorf("unknown College edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	name           *string
	_path          *string
	size           *int64
	addsize        *int64
	is_disabled    *bool
	created_time   *time.Time
	deleted_time   *time.Time
	modified_time  *time.Time
	clearedFields  map[string]struct{}
	creator        *uint32
	clearedcreator bool
	project        map[uint32]struct{}
	removedproject map[uint32]struct{}
	clearedproject bool
	sample         *uint8
	clearedsample  bool
	done           bool
	oldValue       func(context.Context) (*File, error)
	predicates     []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id uint32) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of File entities.
func (m *FileMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *FileMutation) SetUID(u uint32) {
	m.creator = &u
}

// UID returns the value of the "uid" field in the mutation.
func (m *FileMutation) UID() (r uint32, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *FileMutation) ResetUID() {
	m.creator = nil
}

// SetName sets the "name" field.
func (m *FileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FileMutation) ResetName() {
	m.name = nil
}

// SetPath sets the "path" field.
func (m *FileMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *FileMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *FileMutation) ResetPath() {
	m._path = nil
}

// SetSize sets the "size" field.
func (m *FileMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FileMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *FileMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FileMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of the "size" field.
func (m *FileMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[file.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *FileMutation) SizeCleared() bool {
	_, ok := m.clearedFields[file.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *FileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, file.FieldSize)
}

// SetIsDisabled sets the "is_disabled" field.
func (m *FileMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *FileMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *FileMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *FileMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *FileMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *FileMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *FileMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *FileMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDeletedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ClearDeletedTime clears the value of the "deleted_time" field.
func (m *FileMutation) ClearDeletedTime() {
	m.deleted_time = nil
	m.clearedFields[file.FieldDeletedTime] = struct{}{}
}

// DeletedTimeCleared returns if the "deleted_time" field was cleared in this mutation.
func (m *FileMutation) DeletedTimeCleared() bool {
	_, ok := m.clearedFields[file.FieldDeletedTime]
	return ok
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *FileMutation) ResetDeletedTime() {
	m.deleted_time = nil
	delete(m.clearedFields, file.FieldDeletedTime)
}

// SetModifiedTime sets the "modified_time" field.
func (m *FileMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *FileMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldModifiedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ClearModifiedTime clears the value of the "modified_time" field.
func (m *FileMutation) ClearModifiedTime() {
	m.modified_time = nil
	m.clearedFields[file.FieldModifiedTime] = struct{}{}
}

// ModifiedTimeCleared returns if the "modified_time" field was cleared in this mutation.
func (m *FileMutation) ModifiedTimeCleared() bool {
	_, ok := m.clearedFields[file.FieldModifiedTime]
	return ok
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *FileMutation) ResetModifiedTime() {
	m.modified_time = nil
	delete(m.clearedFields, file.FieldModifiedTime)
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *FileMutation) SetCreatorID(id uint32) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *FileMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *FileMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *FileMutation) CreatorID() (id uint32, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *FileMutation) CreatorIDs() (ids []uint32) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *FileMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// AddProjectIDs adds the "project" edge to the Project entity by ids.
func (m *FileMutation) AddProjectIDs(ids ...uint32) {
	if m.project == nil {
		m.project = make(map[uint32]struct{})
	}
	for i := range ids {
		m.project[ids[i]] = struct{}{}
	}
}

// ClearProject clears the "project" edge to the Project entity.
func (m *FileMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *FileMutation) ProjectCleared() bool {
	return m.clearedproject
}

// RemoveProjectIDs removes the "project" edge to the Project entity by IDs.
func (m *FileMutation) RemoveProjectIDs(ids ...uint32) {
	if m.removedproject == nil {
		m.removedproject = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.project, ids[i])
		m.removedproject[ids[i]] = struct{}{}
	}
}

// RemovedProject returns the removed IDs of the "project" edge to the Project entity.
func (m *FileMutation) RemovedProjectIDs() (ids []uint32) {
	for id := range m.removedproject {
		ids = append(ids, id)
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
func (m *FileMutation) ProjectIDs() (ids []uint32) {
	for id := range m.project {
		ids = append(ids, id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *FileMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
	m.removedproject = nil
}

// SetSampleID sets the "sample" edge to the SampleFile entity by id.
func (m *FileMutation) SetSampleID(id uint8) {
	m.sample = &id
}

// ClearSample clears the "sample" edge to the SampleFile entity.
func (m *FileMutation) ClearSample() {
	m.clearedsample = true
}

// SampleCleared reports if the "sample" edge to the SampleFile entity was cleared.
func (m *FileMutation) SampleCleared() bool {
	return m.clearedsample
}

// SampleID returns the "sample" edge ID in the mutation.
func (m *FileMutation) SampleID() (id uint8, exists bool) {
	if m.sample != nil {
		return *m.sample, true
	}
	return
}

// SampleIDs returns the "sample" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SampleID instead. It exists only for internal usage by the builders.
func (m *FileMutation) SampleIDs() (ids []uint8) {
	if id := m.sample; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSample resets all changes to the "sample" edge.
func (m *FileMutation) ResetSample() {
	m.sample = nil
	m.clearedsample = false
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.creator != nil {
		fields = append(fields, file.FieldUID)
	}
	if m.name != nil {
		fields = append(fields, file.FieldName)
	}
	if m._path != nil {
		fields = append(fields, file.FieldPath)
	}
	if m.size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m.is_disabled != nil {
		fields = append(fields, file.FieldIsDisabled)
	}
	if m.created_time != nil {
		fields = append(fields, file.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, file.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, file.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldUID:
		return m.UID()
	case file.FieldName:
		return m.Name()
	case file.FieldPath:
		return m.Path()
	case file.FieldSize:
		return m.Size()
	case file.FieldIsDisabled:
		return m.IsDisabled()
	case file.FieldCreatedTime:
		return m.CreatedTime()
	case file.FieldDeletedTime:
		return m.DeletedTime()
	case file.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldUID:
		return m.OldUID(ctx)
	case file.FieldName:
		return m.OldName(ctx)
	case file.FieldPath:
		return m.OldPath(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case file.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case file.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case file.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldUID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case file.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case file.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case file.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case file.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case file.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case file.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, file.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldSize) {
		fields = append(fields, file.FieldSize)
	}
	if m.FieldCleared(file.FieldDeletedTime) {
		fields = append(fields, file.FieldDeletedTime)
	}
	if m.FieldCleared(file.FieldModifiedTime) {
		fields = append(fields, file.FieldModifiedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldSize:
		m.ClearSize()
		return nil
	case file.FieldDeletedTime:
		m.ClearDeletedTime()
		return nil
	case file.FieldModifiedTime:
		m.ClearModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldUID:
		m.ResetUID()
		return nil
	case file.FieldName:
		m.ResetName()
		return nil
	case file.FieldPath:
		m.ResetPath()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case file.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case file.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case file.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.creator != nil {
		edges = append(edges, file.EdgeCreator)
	}
	if m.project != nil {
		edges = append(edges, file.EdgeProject)
	}
	if m.sample != nil {
		edges = append(edges, file.EdgeSample)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeProject:
		ids := make([]ent.Value, 0, len(m.project))
		for id := range m.project {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeSample:
		if id := m.sample; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproject != nil {
		edges = append(edges, file.EdgeProject)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeProject:
		ids := make([]ent.Value, 0, len(m.removedproject))
		for id := range m.removedproject {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreator {
		edges = append(edges, file.EdgeCreator)
	}
	if m.clearedproject {
		edges = append(edges, file.EdgeProject)
	}
	if m.clearedsample {
		edges = append(edges, file.EdgeSample)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeCreator:
		return m.clearedcreator
	case file.EdgeProject:
		return m.clearedproject
	case file.EdgeSample:
		return m.clearedsample
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeCreator:
		m.ClearCreator()
		return nil
	case file.EdgeSample:
		m.ClearSample()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeCreator:
		m.ResetCreator()
		return nil
	case file.EdgeProject:
		m.ResetProject()
		return nil
	case file.EdgeSample:
		m.ResetSample()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// MajorMutation represents an operation that mutates the Major nodes in the graph.
type MajorMutation struct {
	config
	op             Op
	typ            string
	id             *uint16
	name           *string
	is_disabled    *bool
	created_time   *time.Time
	deleted_time   *time.Time
	modified_time  *time.Time
	clearedFields  map[string]struct{}
	college        *uint8
	clearedcollege bool
	classes        map[uint32]struct{}
	removedclasses map[uint32]struct{}
	clearedclasses bool
	done           bool
	oldValue       func(context.Context) (*Major, error)
	predicates     []predicate.Major
}

var _ ent.Mutation = (*MajorMutation)(nil)

// majorOption allows management of the mutation configuration using functional options.
type majorOption func(*MajorMutation)

// newMajorMutation creates new mutation for the Major entity.
func newMajorMutation(c config, op Op, opts ...majorOption) *MajorMutation {
	m := &MajorMutation{
		config:        c,
		op:            op,
		typ:           TypeMajor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMajorID sets the ID field of the mutation.
func withMajorID(id uint16) majorOption {
	return func(m *MajorMutation) {
		var (
			err   error
			once  sync.Once
			value *Major
		)
		m.oldValue = func(ctx context.Context) (*Major, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Major.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMajor sets the old Major of the mutation.
func withMajor(node *Major) majorOption {
	return func(m *MajorMutation) {
		m.oldValue = func(context.Context) (*Major, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MajorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MajorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Major entities.
func (m *MajorMutation) SetID(id uint16) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MajorMutation) ID() (id uint16, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MajorMutation) IDs(ctx context.Context) ([]uint16, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint16{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Major.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCid sets the "cid" field.
func (m *MajorMutation) SetCid(u uint8) {
	m.college = &u
}

// Cid returns the value of the "cid" field in the mutation.
func (m *MajorMutation) Cid() (r uint8, exists bool) {
	v := m.college
	if v == nil {
		return
	}
	return *v, true
}

// OldCid returns the old "cid" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldCid(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCid: %w", err)
	}
	return oldValue.Cid, nil
}

// ResetCid resets all changes to the "cid" field.
func (m *MajorMutation) ResetCid() {
	m.college = nil
}

// SetName sets the "name" field.
func (m *MajorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MajorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MajorMutation) ResetName() {
	m.name = nil
}

// SetIsDisabled sets the "is_disabled" field.
func (m *MajorMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *MajorMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *MajorMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *MajorMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *MajorMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *MajorMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *MajorMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *MajorMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldDeletedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ClearDeletedTime clears the value of the "deleted_time" field.
func (m *MajorMutation) ClearDeletedTime() {
	m.deleted_time = nil
	m.clearedFields[major.FieldDeletedTime] = struct{}{}
}

// DeletedTimeCleared returns if the "deleted_time" field was cleared in this mutation.
func (m *MajorMutation) DeletedTimeCleared() bool {
	_, ok := m.clearedFields[major.FieldDeletedTime]
	return ok
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *MajorMutation) ResetDeletedTime() {
	m.deleted_time = nil
	delete(m.clearedFields, major.FieldDeletedTime)
}

// SetModifiedTime sets the "modified_time" field.
func (m *MajorMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *MajorMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldModifiedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ClearModifiedTime clears the value of the "modified_time" field.
func (m *MajorMutation) ClearModifiedTime() {
	m.modified_time = nil
	m.clearedFields[major.FieldModifiedTime] = struct{}{}
}

// ModifiedTimeCleared returns if the "modified_time" field was cleared in this mutation.
func (m *MajorMutation) ModifiedTimeCleared() bool {
	_, ok := m.clearedFields[major.FieldModifiedTime]
	return ok
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *MajorMutation) ResetModifiedTime() {
	m.modified_time = nil
	delete(m.clearedFields, major.FieldModifiedTime)
}

// SetCollegeID sets the "college" edge to the College entity by id.
func (m *MajorMutation) SetCollegeID(id uint8) {
	m.college = &id
}

// ClearCollege clears the "college" edge to the College entity.
func (m *MajorMutation) ClearCollege() {
	m.clearedcollege = true
}

// CollegeCleared reports if the "college" edge to the College entity was cleared.
func (m *MajorMutation) CollegeCleared() bool {
	return m.clearedcollege
}

// CollegeID returns the "college" edge ID in the mutation.
func (m *MajorMutation) CollegeID() (id uint8, exists bool) {
	if m.college != nil {
		return *m.college, true
	}
	return
}

// CollegeIDs returns the "college" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CollegeID instead. It exists only for internal usage by the builders.
func (m *MajorMutation) CollegeIDs() (ids []uint8) {
	if id := m.college; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCollege resets all changes to the "college" edge.
func (m *MajorMutation) ResetCollege() {
	m.college = nil
	m.clearedcollege = false
}

// AddClassIDs adds the "classes" edge to the Class entity by ids.
func (m *MajorMutation) AddClassIDs(ids ...uint32) {
	if m.classes == nil {
		m.classes = make(map[uint32]struct{})
	}
	for i := range ids {
		m.classes[ids[i]] = struct{}{}
	}
}

// ClearClasses clears the "classes" edge to the Class entity.
func (m *MajorMutation) ClearClasses() {
	m.clearedclasses = true
}

// ClassesCleared reports if the "classes" edge to the Class entity was cleared.
func (m *MajorMutation) ClassesCleared() bool {
	return m.clearedclasses
}

// RemoveClassIDs removes the "classes" edge to the Class entity by IDs.
func (m *MajorMutation) RemoveClassIDs(ids ...uint32) {
	if m.removedclasses == nil {
		m.removedclasses = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.classes, ids[i])
		m.removedclasses[ids[i]] = struct{}{}
	}
}

// RemovedClasses returns the removed IDs of the "classes" edge to the Class entity.
func (m *MajorMutation) RemovedClassesIDs() (ids []uint32) {
	for id := range m.removedclasses {
		ids = append(ids, id)
	}
	return
}

// ClassesIDs returns the "classes" edge IDs in the mutation.
func (m *MajorMutation) ClassesIDs() (ids []uint32) {
	for id := range m.classes {
		ids = append(ids, id)
	}
	return
}

// ResetClasses resets all changes to the "classes" edge.
func (m *MajorMutation) ResetClasses() {
	m.classes = nil
	m.clearedclasses = false
	m.removedclasses = nil
}

// Where appends a list predicates to the MajorMutation builder.
func (m *MajorMutation) Where(ps ...predicate.Major) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MajorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MajorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Major, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MajorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MajorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Major).
func (m *MajorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MajorMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.college != nil {
		fields = append(fields, major.FieldCid)
	}
	if m.name != nil {
		fields = append(fields, major.FieldName)
	}
	if m.is_disabled != nil {
		fields = append(fields, major.FieldIsDisabled)
	}
	if m.created_time != nil {
		fields = append(fields, major.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, major.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, major.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MajorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case major.FieldCid:
		return m.Cid()
	case major.FieldName:
		return m.Name()
	case major.FieldIsDisabled:
		return m.IsDisabled()
	case major.FieldCreatedTime:
		return m.CreatedTime()
	case major.FieldDeletedTime:
		return m.DeletedTime()
	case major.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MajorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case major.FieldCid:
		return m.OldCid(ctx)
	case major.FieldName:
		return m.OldName(ctx)
	case major.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case major.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case major.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case major.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Major field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MajorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case major.FieldCid:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCid(v)
		return nil
	case major.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case major.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case major.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case major.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case major.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Major field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MajorMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MajorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MajorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Major numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MajorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(major.FieldDeletedTime) {
		fields = append(fields, major.FieldDeletedTime)
	}
	if m.FieldCleared(major.FieldModifiedTime) {
		fields = append(fields, major.FieldModifiedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MajorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MajorMutation) ClearField(name string) error {
	switch name {
	case major.FieldDeletedTime:
		m.ClearDeletedTime()
		return nil
	case major.FieldModifiedTime:
		m.ClearModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown Major nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MajorMutation) ResetField(name string) error {
	switch name {
	case major.FieldCid:
		m.ResetCid()
		return nil
	case major.FieldName:
		m.ResetName()
		return nil
	case major.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case major.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case major.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case major.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown Major field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MajorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.college != nil {
		edges = append(edges, major.EdgeCollege)
	}
	if m.classes != nil {
		edges = append(edges, major.EdgeClasses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MajorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case major.EdgeCollege:
		if id := m.college; id != nil {
			return []ent.Value{*id}
		}
	case major.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.classes))
		for id := range m.classes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MajorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedclasses != nil {
		edges = append(edges, major.EdgeClasses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MajorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case major.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.removedclasses))
		for id := range m.removedclasses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MajorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcollege {
		edges = append(edges, major.EdgeCollege)
	}
	if m.clearedclasses {
		edges = append(edges, major.EdgeClasses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MajorMutation) EdgeCleared(name string) bool {
	switch name {
	case major.EdgeCollege:
		return m.clearedcollege
	case major.EdgeClasses:
		return m.clearedclasses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MajorMutation) ClearEdge(name string) error {
	switch name {
	case major.EdgeCollege:
		m.ClearCollege()
		return nil
	}
	return fmt.Errorf("unknown Major unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MajorMutation) ResetEdge(name string) error {
	switch name {
	case major.EdgeCollege:
		m.ResetCollege()
		return nil
	case major.EdgeClasses:
		m.ResetClasses()
		return nil
	}
	return fmt.Errorf("unknown Major edge %s", name)
}

// MenuMutation represents an operation that mutates the Menu nodes in the graph.
type MenuMutation struct {
	config
	op              Op
	typ             string
	id              *uint8
	name            *string
	json_menu       *[]*entity.Menu
	appendjson_menu []*entity.Menu
	created_time    *time.Time
	deleted_time    *time.Time
	modified_time   *time.Time
	is_disabled     *bool
	clearedFields   map[string]struct{}
	role            *uint8
	clearedrole     bool
	done            bool
	oldValue        func(context.Context) (*Menu, error)
	predicates      []predicate.Menu
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows management of the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for the Menu entity.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the ID field of the mutation.
func withMenuID(id uint8) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Menu entities.
func (m *MenuMutation) SetID(id uint8) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuMutation) ID() (id uint8, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuMutation) IDs(ctx context.Context) ([]uint8, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint8{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Menu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MenuMutation) ResetName() {
	m.name = nil
}

// SetJSONMenu sets the "json_menu" field.
func (m *MenuMutation) SetJSONMenu(e []*entity.Menu) {
	m.json_menu = &e
	m.appendjson_menu = nil
}

// JSONMenu returns the value of the "json_menu" field in the mutation.
func (m *MenuMutation) JSONMenu() (r []*entity.Menu, exists bool) {
	v := m.json_menu
	if v == nil {
		return
	}
	return *v, true
}

// OldJSONMenu returns the old "json_menu" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldJSONMenu(ctx context.Context) (v []*entity.Menu, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJSONMenu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJSONMenu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJSONMenu: %w", err)
	}
	return oldValue.JSONMenu, nil
}

// AppendJSONMenu adds e to the "json_menu" field.
func (m *MenuMutation) AppendJSONMenu(e []*entity.Menu) {
	m.appendjson_menu = append(m.appendjson_menu, e...)
}

// AppendedJSONMenu returns the list of values that were appended to the "json_menu" field in this mutation.
func (m *MenuMutation) AppendedJSONMenu() ([]*entity.Menu, bool) {
	if len(m.appendjson_menu) == 0 {
		return nil, false
	}
	return m.appendjson_menu, true
}

// ClearJSONMenu clears the value of the "json_menu" field.
func (m *MenuMutation) ClearJSONMenu() {
	m.json_menu = nil
	m.appendjson_menu = nil
	m.clearedFields[menu.FieldJSONMenu] = struct{}{}
}

// JSONMenuCleared returns if the "json_menu" field was cleared in this mutation.
func (m *MenuMutation) JSONMenuCleared() bool {
	_, ok := m.clearedFields[menu.FieldJSONMenu]
	return ok
}

// ResetJSONMenu resets all changes to the "json_menu" field.
func (m *MenuMutation) ResetJSONMenu() {
	m.json_menu = nil
	m.appendjson_menu = nil
	delete(m.clearedFields, menu.FieldJSONMenu)
}

// SetRid sets the "rid" field.
func (m *MenuMutation) SetRid(u uint8) {
	m.role = &u
}

// Rid returns the value of the "rid" field in the mutation.
func (m *MenuMutation) Rid() (r uint8, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRid returns the old "rid" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldRid(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRid: %w", err)
	}
	return oldValue.Rid, nil
}

// ResetRid resets all changes to the "rid" field.
func (m *MenuMutation) ResetRid() {
	m.role = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *MenuMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *MenuMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *MenuMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *MenuMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *MenuMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDeletedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ClearDeletedTime clears the value of the "deleted_time" field.
func (m *MenuMutation) ClearDeletedTime() {
	m.deleted_time = nil
	m.clearedFields[menu.FieldDeletedTime] = struct{}{}
}

// DeletedTimeCleared returns if the "deleted_time" field was cleared in this mutation.
func (m *MenuMutation) DeletedTimeCleared() bool {
	_, ok := m.clearedFields[menu.FieldDeletedTime]
	return ok
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *MenuMutation) ResetDeletedTime() {
	m.deleted_time = nil
	delete(m.clearedFields, menu.FieldDeletedTime)
}

// SetModifiedTime sets the "modified_time" field.
func (m *MenuMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *MenuMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldModifiedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ClearModifiedTime clears the value of the "modified_time" field.
func (m *MenuMutation) ClearModifiedTime() {
	m.modified_time = nil
	m.clearedFields[menu.FieldModifiedTime] = struct{}{}
}

// ModifiedTimeCleared returns if the "modified_time" field was cleared in this mutation.
func (m *MenuMutation) ModifiedTimeCleared() bool {
	_, ok := m.clearedFields[menu.FieldModifiedTime]
	return ok
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *MenuMutation) ResetModifiedTime() {
	m.modified_time = nil
	delete(m.clearedFields, menu.FieldModifiedTime)
}

// SetIsDisabled sets the "is_disabled" field.
func (m *MenuMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *MenuMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *MenuMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetRoleID sets the "role" edge to the Role entity by id.
func (m *MenuMutation) SetRoleID(id uint8) {
	m.role = &id
}

// ClearRole clears the "role" edge to the Role entity.
func (m *MenuMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *MenuMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleID returns the "role" edge ID in the mutation.
func (m *MenuMutation) RoleID() (id uint8, exists bool) {
	if m.role != nil {
		return *m.role, true
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *MenuMutation) RoleIDs() (ids []uint8) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *MenuMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the MenuMutation builder.
func (m *MenuMutation) Where(ps ...predicate.Menu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Menu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, menu.FieldName)
	}
	if m.json_menu != nil {
		fields = append(fields, menu.FieldJSONMenu)
	}
	if m.role != nil {
		fields = append(fields, menu.FieldRid)
	}
	if m.created_time != nil {
		fields = append(fields, menu.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, menu.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, menu.FieldModifiedTime)
	}
	if m.is_disabled != nil {
		fields = append(fields, menu.FieldIsDisabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldName:
		return m.Name()
	case menu.FieldJSONMenu:
		return m.JSONMenu()
	case menu.FieldRid:
		return m.Rid()
	case menu.FieldCreatedTime:
		return m.CreatedTime()
	case menu.FieldDeletedTime:
		return m.DeletedTime()
	case menu.FieldModifiedTime:
		return m.ModifiedTime()
	case menu.FieldIsDisabled:
		return m.IsDisabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menu.FieldName:
		return m.OldName(ctx)
	case menu.FieldJSONMenu:
		return m.OldJSONMenu(ctx)
	case menu.FieldRid:
		return m.OldRid(ctx)
	case menu.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case menu.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case menu.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	case menu.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	}
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menu.FieldJSONMenu:
		v, ok := value.([]*entity.Menu)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJSONMenu(v)
		return nil
	case menu.FieldRid:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRid(v)
		return nil
	case menu.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case menu.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case menu.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	case menu.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menu.FieldJSONMenu) {
		fields = append(fields, menu.FieldJSONMenu)
	}
	if m.FieldCleared(menu.FieldDeletedTime) {
		fields = append(fields, menu.FieldDeletedTime)
	}
	if m.FieldCleared(menu.FieldModifiedTime) {
		fields = append(fields, menu.FieldModifiedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	switch name {
	case menu.FieldJSONMenu:
		m.ClearJSONMenu()
		return nil
	case menu.FieldDeletedTime:
		m.ClearDeletedTime()
		return nil
	case menu.FieldModifiedTime:
		m.ClearModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	switch name {
	case menu.FieldName:
		m.ResetName()
		return nil
	case menu.FieldJSONMenu:
		m.ResetJSONMenu()
		return nil
	case menu.FieldRid:
		m.ResetRid()
		return nil
	case menu.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case menu.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case menu.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	case menu.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.role != nil {
		edges = append(edges, menu.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrole {
		edges = append(edges, menu.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	switch name {
	case menu.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	switch name {
	case menu.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	switch name {
	case menu.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown Menu edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op            Op
	typ           string
	id            *uint16
	action        *string
	description   *string
	is_disabled   *bool
	created_time  *time.Time
	deleted_time  *time.Time
	modified_time *time.Time
	clearedFields map[string]struct{}
	roles         map[uint8]struct{}
	removedroles  map[uint8]struct{}
	clearedroles  bool
	done          bool
	oldValue      func(context.Context) (*Permission, error)
	predicates    []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id uint16) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Permission entities.
func (m *PermissionMutation) SetID(id uint16) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id uint16, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]uint16, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint16{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAction sets the "action" field.
func (m *PermissionMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *PermissionMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *PermissionMutation) ResetAction() {
	m.action = nil
}

// SetDescription sets the "description" field.
func (m *PermissionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PermissionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PermissionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[permission.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PermissionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[permission.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PermissionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, permission.FieldDescription)
}

// SetIsDisabled sets the "is_disabled" field.
func (m *PermissionMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *PermissionMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *PermissionMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *PermissionMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *PermissionMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *PermissionMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *PermissionMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *PermissionMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDeletedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ClearDeletedTime clears the value of the "deleted_time" field.
func (m *PermissionMutation) ClearDeletedTime() {
	m.deleted_time = nil
	m.clearedFields[permission.FieldDeletedTime] = struct{}{}
}

// DeletedTimeCleared returns if the "deleted_time" field was cleared in this mutation.
func (m *PermissionMutation) DeletedTimeCleared() bool {
	_, ok := m.clearedFields[permission.FieldDeletedTime]
	return ok
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *PermissionMutation) ResetDeletedTime() {
	m.deleted_time = nil
	delete(m.clearedFields, permission.FieldDeletedTime)
}

// SetModifiedTime sets the "modified_time" field.
func (m *PermissionMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *PermissionMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldModifiedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ClearModifiedTime clears the value of the "modified_time" field.
func (m *PermissionMutation) ClearModifiedTime() {
	m.modified_time = nil
	m.clearedFields[permission.FieldModifiedTime] = struct{}{}
}

// ModifiedTimeCleared returns if the "modified_time" field was cleared in this mutation.
func (m *PermissionMutation) ModifiedTimeCleared() bool {
	_, ok := m.clearedFields[permission.FieldModifiedTime]
	return ok
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *PermissionMutation) ResetModifiedTime() {
	m.modified_time = nil
	delete(m.clearedFields, permission.FieldModifiedTime)
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *PermissionMutation) AddRoleIDs(ids ...uint8) {
	if m.roles == nil {
		m.roles = make(map[uint8]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *PermissionMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *PermissionMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *PermissionMutation) RemoveRoleIDs(ids ...uint8) {
	if m.removedroles == nil {
		m.removedroles = make(map[uint8]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *PermissionMutation) RemovedRolesIDs() (ids []uint8) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *PermissionMutation) RolesIDs() (ids []uint8) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *PermissionMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Permission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.action != nil {
		fields = append(fields, permission.FieldAction)
	}
	if m.description != nil {
		fields = append(fields, permission.FieldDescription)
	}
	if m.is_disabled != nil {
		fields = append(fields, permission.FieldIsDisabled)
	}
	if m.created_time != nil {
		fields = append(fields, permission.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, permission.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, permission.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldAction:
		return m.Action()
	case permission.FieldDescription:
		return m.Description()
	case permission.FieldIsDisabled:
		return m.IsDisabled()
	case permission.FieldCreatedTime:
		return m.CreatedTime()
	case permission.FieldDeletedTime:
		return m.DeletedTime()
	case permission.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldAction:
		return m.OldAction(ctx)
	case permission.FieldDescription:
		return m.OldDescription(ctx)
	case permission.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case permission.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case permission.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case permission.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case permission.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case permission.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case permission.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case permission.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case permission.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permission.FieldDescription) {
		fields = append(fields, permission.FieldDescription)
	}
	if m.FieldCleared(permission.FieldDeletedTime) {
		fields = append(fields, permission.FieldDeletedTime)
	}
	if m.FieldCleared(permission.FieldModifiedTime) {
		fields = append(fields, permission.FieldModifiedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	switch name {
	case permission.FieldDescription:
		m.ClearDescription()
		return nil
	case permission.FieldDeletedTime:
		m.ClearDeletedTime()
		return nil
	case permission.FieldModifiedTime:
		m.ClearModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldAction:
		m.ResetAction()
		return nil
	case permission.FieldDescription:
		m.ResetDescription()
		return nil
	case permission.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case permission.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case permission.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case permission.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roles != nil {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroles != nil {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedroles {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint32
	title                 *string
	goal                  *string
	principle             *string
	process_and_method    *string
	step                  *string
	result_and_conclusion *string
	requirement           *string
	review_status         *uint8
	addreview_status      *int8
	is_disabled           *bool
	created_time          *time.Time
	deleted_time          *time.Time
	modified_time         *time.Time
	clearedFields         map[string]struct{}
	user                  *uint32
	cleareduser           bool
	attachments           map[uint32]struct{}
	removedattachments    map[uint32]struct{}
	clearedattachments    bool
	review_project        map[uint32]struct{}
	removedreview_project map[uint32]struct{}
	clearedreview_project bool
	done                  bool
	oldValue              func(context.Context) (*Project, error)
	predicates            []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id uint32) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Project entities.
func (m *ProjectMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *ProjectMutation) SetUID(u uint32) {
	m.user = &u
}

// UID returns the value of the "uid" field in the mutation.
func (m *ProjectMutation) UID() (r uint32, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ClearUID clears the value of the "uid" field.
func (m *ProjectMutation) ClearUID() {
	m.user = nil
	m.clearedFields[project.FieldUID] = struct{}{}
}

// UIDCleared returns if the "uid" field was cleared in this mutation.
func (m *ProjectMutation) UIDCleared() bool {
	_, ok := m.clearedFields[project.FieldUID]
	return ok
}

// ResetUID resets all changes to the "uid" field.
func (m *ProjectMutation) ResetUID() {
	m.user = nil
	delete(m.clearedFields, project.FieldUID)
}

// SetTitle sets the "title" field.
func (m *ProjectMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ProjectMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ProjectMutation) ResetTitle() {
	m.title = nil
}

// SetGoal sets the "goal" field.
func (m *ProjectMutation) SetGoal(s string) {
	m.goal = &s
}

// Goal returns the value of the "goal" field in the mutation.
func (m *ProjectMutation) Goal() (r string, exists bool) {
	v := m.goal
	if v == nil {
		return
	}
	return *v, true
}

// OldGoal returns the old "goal" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGoal(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoal: %w", err)
	}
	return oldValue.Goal, nil
}

// ResetGoal resets all changes to the "goal" field.
func (m *ProjectMutation) ResetGoal() {
	m.goal = nil
}

// SetPrinciple sets the "principle" field.
func (m *ProjectMutation) SetPrinciple(s string) {
	m.principle = &s
}

// Principle returns the value of the "principle" field in the mutation.
func (m *ProjectMutation) Principle() (r string, exists bool) {
	v := m.principle
	if v == nil {
		return
	}
	return *v, true
}

// OldPrinciple returns the old "principle" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldPrinciple(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrinciple is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrinciple requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrinciple: %w", err)
	}
	return oldValue.Principle, nil
}

// ResetPrinciple resets all changes to the "principle" field.
func (m *ProjectMutation) ResetPrinciple() {
	m.principle = nil
}

// SetProcessAndMethod sets the "process_and_method" field.
func (m *ProjectMutation) SetProcessAndMethod(s string) {
	m.process_and_method = &s
}

// ProcessAndMethod returns the value of the "process_and_method" field in the mutation.
func (m *ProjectMutation) ProcessAndMethod() (r string, exists bool) {
	v := m.process_and_method
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessAndMethod returns the old "process_and_method" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldProcessAndMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessAndMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessAndMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessAndMethod: %w", err)
	}
	return oldValue.ProcessAndMethod, nil
}

// ResetProcessAndMethod resets all changes to the "process_and_method" field.
func (m *ProjectMutation) ResetProcessAndMethod() {
	m.process_and_method = nil
}

// SetStep sets the "step" field.
func (m *ProjectMutation) SetStep(s string) {
	m.step = &s
}

// Step returns the value of the "step" field in the mutation.
func (m *ProjectMutation) Step() (r string, exists bool) {
	v := m.step
	if v == nil {
		return
	}
	return *v, true
}

// OldStep returns the old "step" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldStep(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStep: %w", err)
	}
	return oldValue.Step, nil
}

// ResetStep resets all changes to the "step" field.
func (m *ProjectMutation) ResetStep() {
	m.step = nil
}

// SetResultAndConclusion sets the "result_and_conclusion" field.
func (m *ProjectMutation) SetResultAndConclusion(s string) {
	m.result_and_conclusion = &s
}

// ResultAndConclusion returns the value of the "result_and_conclusion" field in the mutation.
func (m *ProjectMutation) ResultAndConclusion() (r string, exists bool) {
	v := m.result_and_conclusion
	if v == nil {
		return
	}
	return *v, true
}

// OldResultAndConclusion returns the old "result_and_conclusion" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldResultAndConclusion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResultAndConclusion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResultAndConclusion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultAndConclusion: %w", err)
	}
	return oldValue.ResultAndConclusion, nil
}

// ResetResultAndConclusion resets all changes to the "result_and_conclusion" field.
func (m *ProjectMutation) ResetResultAndConclusion() {
	m.result_and_conclusion = nil
}

// SetRequirement sets the "requirement" field.
func (m *ProjectMutation) SetRequirement(s string) {
	m.requirement = &s
}

// Requirement returns the value of the "requirement" field in the mutation.
func (m *ProjectMutation) Requirement() (r string, exists bool) {
	v := m.requirement
	if v == nil {
		return
	}
	return *v, true
}

// OldRequirement returns the old "requirement" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldRequirement(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequirement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequirement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequirement: %w", err)
	}
	return oldValue.Requirement, nil
}

// ResetRequirement resets all changes to the "requirement" field.
func (m *ProjectMutation) ResetRequirement() {
	m.requirement = nil
}

// SetReviewStatus sets the "review_status" field.
func (m *ProjectMutation) SetReviewStatus(u uint8) {
	m.review_status = &u
	m.addreview_status = nil
}

// ReviewStatus returns the value of the "review_status" field in the mutation.
func (m *ProjectMutation) ReviewStatus() (r uint8, exists bool) {
	v := m.review_status
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewStatus returns the old "review_status" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldReviewStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewStatus: %w", err)
	}
	return oldValue.ReviewStatus, nil
}

// AddReviewStatus adds u to the "review_status" field.
func (m *ProjectMutation) AddReviewStatus(u int8) {
	if m.addreview_status != nil {
		*m.addreview_status += u
	} else {
		m.addreview_status = &u
	}
}

// AddedReviewStatus returns the value that was added to the "review_status" field in this mutation.
func (m *ProjectMutation) AddedReviewStatus() (r int8, exists bool) {
	v := m.addreview_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetReviewStatus resets all changes to the "review_status" field.
func (m *ProjectMutation) ResetReviewStatus() {
	m.review_status = nil
	m.addreview_status = nil
}

// SetIsDisabled sets the "is_disabled" field.
func (m *ProjectMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *ProjectMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *ProjectMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *ProjectMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *ProjectMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *ProjectMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *ProjectMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *ProjectMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDeletedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ClearDeletedTime clears the value of the "deleted_time" field.
func (m *ProjectMutation) ClearDeletedTime() {
	m.deleted_time = nil
	m.clearedFields[project.FieldDeletedTime] = struct{}{}
}

// DeletedTimeCleared returns if the "deleted_time" field was cleared in this mutation.
func (m *ProjectMutation) DeletedTimeCleared() bool {
	_, ok := m.clearedFields[project.FieldDeletedTime]
	return ok
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *ProjectMutation) ResetDeletedTime() {
	m.deleted_time = nil
	delete(m.clearedFields, project.FieldDeletedTime)
}

// SetModifiedTime sets the "modified_time" field.
func (m *ProjectMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *ProjectMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldModifiedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ClearModifiedTime clears the value of the "modified_time" field.
func (m *ProjectMutation) ClearModifiedTime() {
	m.modified_time = nil
	m.clearedFields[project.FieldModifiedTime] = struct{}{}
}

// ModifiedTimeCleared returns if the "modified_time" field was cleared in this mutation.
func (m *ProjectMutation) ModifiedTimeCleared() bool {
	_, ok := m.clearedFields[project.FieldModifiedTime]
	return ok
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *ProjectMutation) ResetModifiedTime() {
	m.modified_time = nil
	delete(m.clearedFields, project.FieldModifiedTime)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ProjectMutation) SetUserID(id uint32) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProjectMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProjectMutation) UserCleared() bool {
	return m.UIDCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ProjectMutation) UserID() (id uint32, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) UserIDs() (ids []uint32) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProjectMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddAttachmentIDs adds the "attachments" edge to the File entity by ids.
func (m *ProjectMutation) AddAttachmentIDs(ids ...uint32) {
	if m.attachments == nil {
		m.attachments = make(map[uint32]struct{})
	}
	for i := range ids {
		m.attachments[ids[i]] = struct{}{}
	}
}

// ClearAttachments clears the "attachments" edge to the File entity.
func (m *ProjectMutation) ClearAttachments() {
	m.clearedattachments = true
}

// AttachmentsCleared reports if the "attachments" edge to the File entity was cleared.
func (m *ProjectMutation) AttachmentsCleared() bool {
	return m.clearedattachments
}

// RemoveAttachmentIDs removes the "attachments" edge to the File entity by IDs.
func (m *ProjectMutation) RemoveAttachmentIDs(ids ...uint32) {
	if m.removedattachments == nil {
		m.removedattachments = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.attachments, ids[i])
		m.removedattachments[ids[i]] = struct{}{}
	}
}

// RemovedAttachments returns the removed IDs of the "attachments" edge to the File entity.
func (m *ProjectMutation) RemovedAttachmentsIDs() (ids []uint32) {
	for id := range m.removedattachments {
		ids = append(ids, id)
	}
	return
}

// AttachmentsIDs returns the "attachments" edge IDs in the mutation.
func (m *ProjectMutation) AttachmentsIDs() (ids []uint32) {
	for id := range m.attachments {
		ids = append(ids, id)
	}
	return
}

// ResetAttachments resets all changes to the "attachments" edge.
func (m *ProjectMutation) ResetAttachments() {
	m.attachments = nil
	m.clearedattachments = false
	m.removedattachments = nil
}

// AddReviewProjectIDs adds the "review_project" edge to the ReviewProject entity by ids.
func (m *ProjectMutation) AddReviewProjectIDs(ids ...uint32) {
	if m.review_project == nil {
		m.review_project = make(map[uint32]struct{})
	}
	for i := range ids {
		m.review_project[ids[i]] = struct{}{}
	}
}

// ClearReviewProject clears the "review_project" edge to the ReviewProject entity.
func (m *ProjectMutation) ClearReviewProject() {
	m.clearedreview_project = true
}

// ReviewProjectCleared reports if the "review_project" edge to the ReviewProject entity was cleared.
func (m *ProjectMutation) ReviewProjectCleared() bool {
	return m.clearedreview_project
}

// RemoveReviewProjectIDs removes the "review_project" edge to the ReviewProject entity by IDs.
func (m *ProjectMutation) RemoveReviewProjectIDs(ids ...uint32) {
	if m.removedreview_project == nil {
		m.removedreview_project = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.review_project, ids[i])
		m.removedreview_project[ids[i]] = struct{}{}
	}
}

// RemovedReviewProject returns the removed IDs of the "review_project" edge to the ReviewProject entity.
func (m *ProjectMutation) RemovedReviewProjectIDs() (ids []uint32) {
	for id := range m.removedreview_project {
		ids = append(ids, id)
	}
	return
}

// ReviewProjectIDs returns the "review_project" edge IDs in the mutation.
func (m *ProjectMutation) ReviewProjectIDs() (ids []uint32) {
	for id := range m.review_project {
		ids = append(ids, id)
	}
	return
}

// ResetReviewProject resets all changes to the "review_project" edge.
func (m *ProjectMutation) ResetReviewProject() {
	m.review_project = nil
	m.clearedreview_project = false
	m.removedreview_project = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.user != nil {
		fields = append(fields, project.FieldUID)
	}
	if m.title != nil {
		fields = append(fields, project.FieldTitle)
	}
	if m.goal != nil {
		fields = append(fields, project.FieldGoal)
	}
	if m.principle != nil {
		fields = append(fields, project.FieldPrinciple)
	}
	if m.process_and_method != nil {
		fields = append(fields, project.FieldProcessAndMethod)
	}
	if m.step != nil {
		fields = append(fields, project.FieldStep)
	}
	if m.result_and_conclusion != nil {
		fields = append(fields, project.FieldResultAndConclusion)
	}
	if m.requirement != nil {
		fields = append(fields, project.FieldRequirement)
	}
	if m.review_status != nil {
		fields = append(fields, project.FieldReviewStatus)
	}
	if m.is_disabled != nil {
		fields = append(fields, project.FieldIsDisabled)
	}
	if m.created_time != nil {
		fields = append(fields, project.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, project.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, project.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldUID:
		return m.UID()
	case project.FieldTitle:
		return m.Title()
	case project.FieldGoal:
		return m.Goal()
	case project.FieldPrinciple:
		return m.Principle()
	case project.FieldProcessAndMethod:
		return m.ProcessAndMethod()
	case project.FieldStep:
		return m.Step()
	case project.FieldResultAndConclusion:
		return m.ResultAndConclusion()
	case project.FieldRequirement:
		return m.Requirement()
	case project.FieldReviewStatus:
		return m.ReviewStatus()
	case project.FieldIsDisabled:
		return m.IsDisabled()
	case project.FieldCreatedTime:
		return m.CreatedTime()
	case project.FieldDeletedTime:
		return m.DeletedTime()
	case project.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldUID:
		return m.OldUID(ctx)
	case project.FieldTitle:
		return m.OldTitle(ctx)
	case project.FieldGoal:
		return m.OldGoal(ctx)
	case project.FieldPrinciple:
		return m.OldPrinciple(ctx)
	case project.FieldProcessAndMethod:
		return m.OldProcessAndMethod(ctx)
	case project.FieldStep:
		return m.OldStep(ctx)
	case project.FieldResultAndConclusion:
		return m.OldResultAndConclusion(ctx)
	case project.FieldRequirement:
		return m.OldRequirement(ctx)
	case project.FieldReviewStatus:
		return m.OldReviewStatus(ctx)
	case project.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case project.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case project.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case project.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldUID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case project.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case project.FieldGoal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoal(v)
		return nil
	case project.FieldPrinciple:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrinciple(v)
		return nil
	case project.FieldProcessAndMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessAndMethod(v)
		return nil
	case project.FieldStep:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStep(v)
		return nil
	case project.FieldResultAndConclusion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultAndConclusion(v)
		return nil
	case project.FieldRequirement:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequirement(v)
		return nil
	case project.FieldReviewStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewStatus(v)
		return nil
	case project.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case project.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case project.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case project.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	var fields []string
	if m.addreview_status != nil {
		fields = append(fields, project.FieldReviewStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case project.FieldReviewStatus:
		return m.AddedReviewStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case project.FieldReviewStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReviewStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldUID) {
		fields = append(fields, project.FieldUID)
	}
	if m.FieldCleared(project.FieldDeletedTime) {
		fields = append(fields, project.FieldDeletedTime)
	}
	if m.FieldCleared(project.FieldModifiedTime) {
		fields = append(fields, project.FieldModifiedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldUID:
		m.ClearUID()
		return nil
	case project.FieldDeletedTime:
		m.ClearDeletedTime()
		return nil
	case project.FieldModifiedTime:
		m.ClearModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldUID:
		m.ResetUID()
		return nil
	case project.FieldTitle:
		m.ResetTitle()
		return nil
	case project.FieldGoal:
		m.ResetGoal()
		return nil
	case project.FieldPrinciple:
		m.ResetPrinciple()
		return nil
	case project.FieldProcessAndMethod:
		m.ResetProcessAndMethod()
		return nil
	case project.FieldStep:
		m.ResetStep()
		return nil
	case project.FieldResultAndConclusion:
		m.ResetResultAndConclusion()
		return nil
	case project.FieldRequirement:
		m.ResetRequirement()
		return nil
	case project.FieldReviewStatus:
		m.ResetReviewStatus()
		return nil
	case project.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case project.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case project.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case project.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, project.EdgeUser)
	}
	if m.attachments != nil {
		edges = append(edges, project.EdgeAttachments)
	}
	if m.review_project != nil {
		edges = append(edges, project.EdgeReviewProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.attachments))
		for id := range m.attachments {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeReviewProject:
		ids := make([]ent.Value, 0, len(m.review_project))
		for id := range m.review_project {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedattachments != nil {
		edges = append(edges, project.EdgeAttachments)
	}
	if m.removedreview_project != nil {
		edges = append(edges, project.EdgeReviewProject)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.removedattachments))
		for id := range m.removedattachments {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeReviewProject:
		ids := make([]ent.Value, 0, len(m.removedreview_project))
		for id := range m.removedreview_project {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, project.EdgeUser)
	}
	if m.clearedattachments {
		edges = append(edges, project.EdgeAttachments)
	}
	if m.clearedreview_project {
		edges = append(edges, project.EdgeReviewProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeUser:
		return m.cleareduser
	case project.EdgeAttachments:
		return m.clearedattachments
	case project.EdgeReviewProject:
		return m.clearedreview_project
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	case project.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeUser:
		m.ResetUser()
		return nil
	case project.EdgeAttachments:
		m.ResetAttachments()
		return nil
	case project.EdgeReviewProject:
		m.ResetReviewProject()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ProjectFileMutation represents an operation that mutates the ProjectFile nodes in the graph.
type ProjectFileMutation struct {
	config
	op             Op
	typ            string
	created_time   *time.Time
	clearedFields  map[string]struct{}
	project        *uint32
	clearedproject bool
	files          *uint32
	clearedfiles   bool
	done           bool
	oldValue       func(context.Context) (*ProjectFile, error)
	predicates     []predicate.ProjectFile
}

var _ ent.Mutation = (*ProjectFileMutation)(nil)

// projectfileOption allows management of the mutation configuration using functional options.
type projectfileOption func(*ProjectFileMutation)

// newProjectFileMutation creates new mutation for the ProjectFile entity.
func newProjectFileMutation(c config, op Op, opts ...projectfileOption) *ProjectFileMutation {
	m := &ProjectFileMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetPid sets the "pid" field.
func (m *ProjectFileMutation) SetPid(u uint32) {
	m.project = &u
}

// Pid returns the value of the "pid" field in the mutation.
func (m *ProjectFileMutation) Pid() (r uint32, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// ResetPid resets all changes to the "pid" field.
func (m *ProjectFileMutation) ResetPid() {
	m.project = nil
}

// SetFid sets the "fid" field.
func (m *ProjectFileMutation) SetFid(u uint32) {
	m.files = &u
}

// Fid returns the value of the "fid" field in the mutation.
func (m *ProjectFileMutation) Fid() (r uint32, exists bool) {
	v := m.files
	if v == nil {
		return
	}
	return *v, true
}

// ResetFid resets all changes to the "fid" field.
func (m *ProjectFileMutation) ResetFid() {
	m.files = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *ProjectFileMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *ProjectFileMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *ProjectFileMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *ProjectFileMutation) SetProjectID(id uint32) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectFileMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectFileMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *ProjectFileMutation) ProjectID() (id uint32, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectFileMutation) ProjectIDs() (ids []uint32) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectFileMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetFilesID sets the "files" edge to the File entity by id.
func (m *ProjectFileMutation) SetFilesID(id uint32) {
	m.files = &id
}

// ClearFiles clears the "files" edge to the File entity.
func (m *ProjectFileMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *ProjectFileMutation) FilesCleared() bool {
	return m.clearedfiles
}

// FilesID returns the "files" edge ID in the mutation.
func (m *ProjectFileMutation) FilesID() (id uint32, exists bool) {
	if m.files != nil {
		return *m.files, true
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FilesID instead. It exists only for internal usage by the builders.
func (m *ProjectFileMutation) FilesIDs() (ids []uint32) {
	if id := m.files; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *ProjectFileMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
}

// Where appends a list predicates to the ProjectFileMutation builder.
func (m *ProjectFileMutation) Where(ps ...predicate.ProjectFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProjectFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProjectFile).
func (m *ProjectFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectFileMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.project != nil {
		fields = append(fields, projectfile.FieldPid)
	}
	if m.files != nil {
		fields = append(fields, projectfile.FieldFid)
	}
	if m.created_time != nil {
		fields = append(fields, projectfile.FieldCreatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectfile.FieldPid:
		return m.Pid()
	case projectfile.FieldFid:
		return m.Fid()
	case projectfile.FieldCreatedTime:
		return m.CreatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema ProjectFile does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectfile.FieldPid:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPid(v)
		return nil
	case projectfile.FieldFid:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFid(v)
		return nil
	case projectfile.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectFileMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectFileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectFileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectFileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectFileMutation) ResetField(name string) error {
	switch name {
	case projectfile.FieldPid:
		m.ResetPid()
		return nil
	case projectfile.FieldFid:
		m.ResetFid()
		return nil
	case projectfile.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown ProjectFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, projectfile.EdgeProject)
	}
	if m.files != nil {
		edges = append(edges, projectfile.EdgeFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectFileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectfile.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case projectfile.EdgeFiles:
		if id := m.files; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectFileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, projectfile.EdgeProject)
	}
	if m.clearedfiles {
		edges = append(edges, projectfile.EdgeFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectFileMutation) EdgeCleared(name string) bool {
	switch name {
	case projectfile.EdgeProject:
		return m.clearedproject
	case projectfile.EdgeFiles:
		return m.clearedfiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectFileMutation) ClearEdge(name string) error {
	switch name {
	case projectfile.EdgeProject:
		m.ClearProject()
		return nil
	case projectfile.EdgeFiles:
		m.ClearFiles()
		return nil
	}
	return fmt.Errorf("unknown ProjectFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectFileMutation) ResetEdge(name string) error {
	switch name {
	case projectfile.EdgeProject:
		m.ResetProject()
		return nil
	case projectfile.EdgeFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown ProjectFile edge %s", name)
}

// ReviewProjectMutation represents an operation that mutates the ReviewProject nodes in the graph.
type ReviewProjectMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uint32
	workflow_id                  *string
	run_id                       *string
	status                       *uint8
	addstatus                    *int8
	created_time                 *time.Time
	deleted_time                 *time.Time
	modified_time                *time.Time
	clearedFields                map[string]struct{}
	applicant                    *uint32
	clearedapplicant             bool
	project                      *uint32
	clearedproject               bool
	review_project_detail        map[int]struct{}
	removedreview_project_detail map[int]struct{}
	clearedreview_project_detail bool
	done                         bool
	oldValue                     func(context.Context) (*ReviewProject, error)
	predicates                   []predicate.ReviewProject
}

var _ ent.Mutation = (*ReviewProjectMutation)(nil)

// reviewprojectOption allows management of the mutation configuration using functional options.
type reviewprojectOption func(*ReviewProjectMutation)

// newReviewProjectMutation creates new mutation for the ReviewProject entity.
func newReviewProjectMutation(c config, op Op, opts ...reviewprojectOption) *ReviewProjectMutation {
	m := &ReviewProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeReviewProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReviewProjectID sets the ID field of the mutation.
func withReviewProjectID(id uint32) reviewprojectOption {
	return func(m *ReviewProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *ReviewProject
		)
		m.oldValue = func(ctx context.Context) (*ReviewProject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReviewProject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReviewProject sets the old ReviewProject of the mutation.
func withReviewProject(node *ReviewProject) reviewprojectOption {
	return func(m *ReviewProjectMutation) {
		m.oldValue = func(context.Context) (*ReviewProject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReviewProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReviewProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ReviewProject entities.
func (m *ReviewProjectMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReviewProjectMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReviewProjectMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReviewProject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *ReviewProjectMutation) SetProjectID(u uint32) {
	m.project = &u
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ReviewProjectMutation) ProjectID() (r uint32, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the ReviewProject entity.
// If the ReviewProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewProjectMutation) OldProjectID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ReviewProjectMutation) ResetProjectID() {
	m.project = nil
}

// SetWorkflowID sets the "workflow_id" field.
func (m *ReviewProjectMutation) SetWorkflowID(s string) {
	m.workflow_id = &s
}

// WorkflowID returns the value of the "workflow_id" field in the mutation.
func (m *ReviewProjectMutation) WorkflowID() (r string, exists bool) {
	v := m.workflow_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowID returns the old "workflow_id" field's value of the ReviewProject entity.
// If the ReviewProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewProjectMutation) OldWorkflowID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowID: %w", err)
	}
	return oldValue.WorkflowID, nil
}

// ResetWorkflowID resets all changes to the "workflow_id" field.
func (m *ReviewProjectMutation) ResetWorkflowID() {
	m.workflow_id = nil
}

// SetRunID sets the "run_id" field.
func (m *ReviewProjectMutation) SetRunID(s string) {
	m.run_id = &s
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *ReviewProjectMutation) RunID() (r string, exists bool) {
	v := m.run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the ReviewProject entity.
// If the ReviewProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewProjectMutation) OldRunID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// ResetRunID resets all changes to the "run_id" field.
func (m *ReviewProjectMutation) ResetRunID() {
	m.run_id = nil
}

// SetApplicantID sets the "applicant_id" field.
func (m *ReviewProjectMutation) SetApplicantID(u uint32) {
	m.applicant = &u
}

// ApplicantID returns the value of the "applicant_id" field in the mutation.
func (m *ReviewProjectMutation) ApplicantID() (r uint32, exists bool) {
	v := m.applicant
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicantID returns the old "applicant_id" field's value of the ReviewProject entity.
// If the ReviewProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewProjectMutation) OldApplicantID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicantID: %w", err)
	}
	return oldValue.ApplicantID, nil
}

// ResetApplicantID resets all changes to the "applicant_id" field.
func (m *ReviewProjectMutation) ResetApplicantID() {
	m.applicant = nil
}

// SetStatus sets the "status" field.
func (m *ReviewProjectMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ReviewProjectMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ReviewProject entity.
// If the ReviewProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewProjectMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *ReviewProjectMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ReviewProjectMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ReviewProjectMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *ReviewProjectMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *ReviewProjectMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the ReviewProject entity.
// If the ReviewProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewProjectMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *ReviewProjectMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *ReviewProjectMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *ReviewProjectMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the ReviewProject entity.
// If the ReviewProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewProjectMutation) OldDeletedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ClearDeletedTime clears the value of the "deleted_time" field.
func (m *ReviewProjectMutation) ClearDeletedTime() {
	m.deleted_time = nil
	m.clearedFields[reviewproject.FieldDeletedTime] = struct{}{}
}

// DeletedTimeCleared returns if the "deleted_time" field was cleared in this mutation.
func (m *ReviewProjectMutation) DeletedTimeCleared() bool {
	_, ok := m.clearedFields[reviewproject.FieldDeletedTime]
	return ok
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *ReviewProjectMutation) ResetDeletedTime() {
	m.deleted_time = nil
	delete(m.clearedFields, reviewproject.FieldDeletedTime)
}

// SetModifiedTime sets the "modified_time" field.
func (m *ReviewProjectMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *ReviewProjectMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the ReviewProject entity.
// If the ReviewProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewProjectMutation) OldModifiedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ClearModifiedTime clears the value of the "modified_time" field.
func (m *ReviewProjectMutation) ClearModifiedTime() {
	m.modified_time = nil
	m.clearedFields[reviewproject.FieldModifiedTime] = struct{}{}
}

// ModifiedTimeCleared returns if the "modified_time" field was cleared in this mutation.
func (m *ReviewProjectMutation) ModifiedTimeCleared() bool {
	_, ok := m.clearedFields[reviewproject.FieldModifiedTime]
	return ok
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *ReviewProjectMutation) ResetModifiedTime() {
	m.modified_time = nil
	delete(m.clearedFields, reviewproject.FieldModifiedTime)
}

// ClearApplicant clears the "applicant" edge to the User entity.
func (m *ReviewProjectMutation) ClearApplicant() {
	m.clearedapplicant = true
}

// ApplicantCleared reports if the "applicant" edge to the User entity was cleared.
func (m *ReviewProjectMutation) ApplicantCleared() bool {
	return m.clearedapplicant
}

// ApplicantIDs returns the "applicant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplicantID instead. It exists only for internal usage by the builders.
func (m *ReviewProjectMutation) ApplicantIDs() (ids []uint32) {
	if id := m.applicant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplicant resets all changes to the "applicant" edge.
func (m *ReviewProjectMutation) ResetApplicant() {
	m.applicant = nil
	m.clearedapplicant = false
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ReviewProjectMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ReviewProjectMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ReviewProjectMutation) ProjectIDs() (ids []uint32) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ReviewProjectMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddReviewProjectDetailIDs adds the "review_project_detail" edge to the ReviewProjectDetail entity by ids.
func (m *ReviewProjectMutation) AddReviewProjectDetailIDs(ids ...int) {
	if m.review_project_detail == nil {
		m.review_project_detail = make(map[int]struct{})
	}
	for i := range ids {
		m.review_project_detail[ids[i]] = struct{}{}
	}
}

// ClearReviewProjectDetail clears the "review_project_detail" edge to the ReviewProjectDetail entity.
func (m *ReviewProjectMutation) ClearReviewProjectDetail() {
	m.clearedreview_project_detail = true
}

// ReviewProjectDetailCleared reports if the "review_project_detail" edge to the ReviewProjectDetail entity was cleared.
func (m *ReviewProjectMutation) ReviewProjectDetailCleared() bool {
	return m.clearedreview_project_detail
}

// RemoveReviewProjectDetailIDs removes the "review_project_detail" edge to the ReviewProjectDetail entity by IDs.
func (m *ReviewProjectMutation) RemoveReviewProjectDetailIDs(ids ...int) {
	if m.removedreview_project_detail == nil {
		m.removedreview_project_detail = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.review_project_detail, ids[i])
		m.removedreview_project_detail[ids[i]] = struct{}{}
	}
}

// RemovedReviewProjectDetail returns the removed IDs of the "review_project_detail" edge to the ReviewProjectDetail entity.
func (m *ReviewProjectMutation) RemovedReviewProjectDetailIDs() (ids []int) {
	for id := range m.removedreview_project_detail {
		ids = append(ids, id)
	}
	return
}

// ReviewProjectDetailIDs returns the "review_project_detail" edge IDs in the mutation.
func (m *ReviewProjectMutation) ReviewProjectDetailIDs() (ids []int) {
	for id := range m.review_project_detail {
		ids = append(ids, id)
	}
	return
}

// ResetReviewProjectDetail resets all changes to the "review_project_detail" edge.
func (m *ReviewProjectMutation) ResetReviewProjectDetail() {
	m.review_project_detail = nil
	m.clearedreview_project_detail = false
	m.removedreview_project_detail = nil
}

// Where appends a list predicates to the ReviewProjectMutation builder.
func (m *ReviewProjectMutation) Where(ps ...predicate.ReviewProject) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReviewProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReviewProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReviewProject, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReviewProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReviewProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReviewProject).
func (m *ReviewProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReviewProjectMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.project != nil {
		fields = append(fields, reviewproject.FieldProjectID)
	}
	if m.workflow_id != nil {
		fields = append(fields, reviewproject.FieldWorkflowID)
	}
	if m.run_id != nil {
		fields = append(fields, reviewproject.FieldRunID)
	}
	if m.applicant != nil {
		fields = append(fields, reviewproject.FieldApplicantID)
	}
	if m.status != nil {
		fields = append(fields, reviewproject.FieldStatus)
	}
	if m.created_time != nil {
		fields = append(fields, reviewproject.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, reviewproject.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, reviewproject.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReviewProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reviewproject.FieldProjectID:
		return m.ProjectID()
	case reviewproject.FieldWorkflowID:
		return m.WorkflowID()
	case reviewproject.FieldRunID:
		return m.RunID()
	case reviewproject.FieldApplicantID:
		return m.ApplicantID()
	case reviewproject.FieldStatus:
		return m.Status()
	case reviewproject.FieldCreatedTime:
		return m.CreatedTime()
	case reviewproject.FieldDeletedTime:
		return m.DeletedTime()
	case reviewproject.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReviewProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reviewproject.FieldProjectID:
		return m.OldProjectID(ctx)
	case reviewproject.FieldWorkflowID:
		return m.OldWorkflowID(ctx)
	case reviewproject.FieldRunID:
		return m.OldRunID(ctx)
	case reviewproject.FieldApplicantID:
		return m.OldApplicantID(ctx)
	case reviewproject.FieldStatus:
		return m.OldStatus(ctx)
	case reviewproject.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case reviewproject.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case reviewproject.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown ReviewProject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reviewproject.FieldProjectID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case reviewproject.FieldWorkflowID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowID(v)
		return nil
	case reviewproject.FieldRunID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case reviewproject.FieldApplicantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicantID(v)
		return nil
	case reviewproject.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case reviewproject.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case reviewproject.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case reviewproject.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown ReviewProject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReviewProjectMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, reviewproject.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReviewProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case reviewproject.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case reviewproject.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ReviewProject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReviewProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reviewproject.FieldDeletedTime) {
		fields = append(fields, reviewproject.FieldDeletedTime)
	}
	if m.FieldCleared(reviewproject.FieldModifiedTime) {
		fields = append(fields, reviewproject.FieldModifiedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReviewProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReviewProjectMutation) ClearField(name string) error {
	switch name {
	case reviewproject.FieldDeletedTime:
		m.ClearDeletedTime()
		return nil
	case reviewproject.FieldModifiedTime:
		m.ClearModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown ReviewProject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReviewProjectMutation) ResetField(name string) error {
	switch name {
	case reviewproject.FieldProjectID:
		m.ResetProjectID()
		return nil
	case reviewproject.FieldWorkflowID:
		m.ResetWorkflowID()
		return nil
	case reviewproject.FieldRunID:
		m.ResetRunID()
		return nil
	case reviewproject.FieldApplicantID:
		m.ResetApplicantID()
		return nil
	case reviewproject.FieldStatus:
		m.ResetStatus()
		return nil
	case reviewproject.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case reviewproject.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case reviewproject.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown ReviewProject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReviewProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.applicant != nil {
		edges = append(edges, reviewproject.EdgeApplicant)
	}
	if m.project != nil {
		edges = append(edges, reviewproject.EdgeProject)
	}
	if m.review_project_detail != nil {
		edges = append(edges, reviewproject.EdgeReviewProjectDetail)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReviewProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reviewproject.EdgeApplicant:
		if id := m.applicant; id != nil {
			return []ent.Value{*id}
		}
	case reviewproject.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case reviewproject.EdgeReviewProjectDetail:
		ids := make([]ent.Value, 0, len(m.review_project_detail))
		for id := range m.review_project_detail {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReviewProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedreview_project_detail != nil {
		edges = append(edges, reviewproject.EdgeReviewProjectDetail)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReviewProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case reviewproject.EdgeReviewProjectDetail:
		ids := make([]ent.Value, 0, len(m.removedreview_project_detail))
		for id := range m.removedreview_project_detail {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReviewProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedapplicant {
		edges = append(edges, reviewproject.EdgeApplicant)
	}
	if m.clearedproject {
		edges = append(edges, reviewproject.EdgeProject)
	}
	if m.clearedreview_project_detail {
		edges = append(edges, reviewproject.EdgeReviewProjectDetail)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReviewProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case reviewproject.EdgeApplicant:
		return m.clearedapplicant
	case reviewproject.EdgeProject:
		return m.clearedproject
	case reviewproject.EdgeReviewProjectDetail:
		return m.clearedreview_project_detail
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReviewProjectMutation) ClearEdge(name string) error {
	switch name {
	case reviewproject.EdgeApplicant:
		m.ClearApplicant()
		return nil
	case reviewproject.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown ReviewProject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReviewProjectMutation) ResetEdge(name string) error {
	switch name {
	case reviewproject.EdgeApplicant:
		m.ResetApplicant()
		return nil
	case reviewproject.EdgeProject:
		m.ResetProject()
		return nil
	case reviewproject.EdgeReviewProjectDetail:
		m.ResetReviewProjectDetail()
		return nil
	}
	return fmt.Errorf("unknown ReviewProject edge %s", name)
}

// ReviewProjectDetailMutation represents an operation that mutates the ReviewProjectDetail nodes in the graph.
type ReviewProjectDetailMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	_order                *uint8
	add_order             *int8
	reviewer              **entity.Reviewer
	executor              **entity.Executor
	typee                 *uint8
	addtypee              *int8
	status                *uint8
	addstatus             *int8
	created_time          *time.Time
	deleted_time          *time.Time
	modified_time         *time.Time
	clearedFields         map[string]struct{}
	review_project        *uint32
	clearedreview_project bool
	done                  bool
	oldValue              func(context.Context) (*ReviewProjectDetail, error)
	predicates            []predicate.ReviewProjectDetail
}

var _ ent.Mutation = (*ReviewProjectDetailMutation)(nil)

// reviewprojectdetailOption allows management of the mutation configuration using functional options.
type reviewprojectdetailOption func(*ReviewProjectDetailMutation)

// newReviewProjectDetailMutation creates new mutation for the ReviewProjectDetail entity.
func newReviewProjectDetailMutation(c config, op Op, opts ...reviewprojectdetailOption) *ReviewProjectDetailMutation {
	m := &ReviewProjectDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeReviewProjectDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReviewProjectDetailID sets the ID field of the mutation.
func withReviewProjectDetailID(id int) reviewprojectdetailOption {
	return func(m *ReviewProjectDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *ReviewProjectDetail
		)
		m.oldValue = func(ctx context.Context) (*ReviewProjectDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReviewProjectDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReviewProjectDetail sets the old ReviewProjectDetail of the mutation.
func withReviewProjectDetail(node *ReviewProjectDetail) reviewprojectdetailOption {
	return func(m *ReviewProjectDetailMutation) {
		m.oldValue = func(context.Context) (*ReviewProjectDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReviewProjectDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReviewProjectDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReviewProjectDetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReviewProjectDetailMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReviewProjectDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReviewProjectID sets the "review_project_id" field.
func (m *ReviewProjectDetailMutation) SetReviewProjectID(u uint32) {
	m.review_project = &u
}

// ReviewProjectID returns the value of the "review_project_id" field in the mutation.
func (m *ReviewProjectDetailMutation) ReviewProjectID() (r uint32, exists bool) {
	v := m.review_project
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewProjectID returns the old "review_project_id" field's value of the ReviewProjectDetail entity.
// If the ReviewProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewProjectDetailMutation) OldReviewProjectID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewProjectID: %w", err)
	}
	return oldValue.ReviewProjectID, nil
}

// ResetReviewProjectID resets all changes to the "review_project_id" field.
func (m *ReviewProjectDetailMutation) ResetReviewProjectID() {
	m.review_project = nil
}

// SetOrder sets the "order" field.
func (m *ReviewProjectDetailMutation) SetOrder(u uint8) {
	m._order = &u
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *ReviewProjectDetailMutation) Order() (r uint8, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the ReviewProjectDetail entity.
// If the ReviewProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewProjectDetailMutation) OldOrder(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds u to the "order" field.
func (m *ReviewProjectDetailMutation) AddOrder(u int8) {
	if m.add_order != nil {
		*m.add_order += u
	} else {
		m.add_order = &u
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *ReviewProjectDetailMutation) AddedOrder() (r int8, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *ReviewProjectDetailMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetReviewer sets the "reviewer" field.
func (m *ReviewProjectDetailMutation) SetReviewer(e *entity.Reviewer) {
	m.reviewer = &e
}

// Reviewer returns the value of the "reviewer" field in the mutation.
func (m *ReviewProjectDetailMutation) Reviewer() (r *entity.Reviewer, exists bool) {
	v := m.reviewer
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewer returns the old "reviewer" field's value of the ReviewProjectDetail entity.
// If the ReviewProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewProjectDetailMutation) OldReviewer(ctx context.Context) (v *entity.Reviewer, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewer: %w", err)
	}
	return oldValue.Reviewer, nil
}

// ResetReviewer resets all changes to the "reviewer" field.
func (m *ReviewProjectDetailMutation) ResetReviewer() {
	m.reviewer = nil
}

// SetExecutor sets the "executor" field.
func (m *ReviewProjectDetailMutation) SetExecutor(e *entity.Executor) {
	m.executor = &e
}

// Executor returns the value of the "executor" field in the mutation.
func (m *ReviewProjectDetailMutation) Executor() (r *entity.Executor, exists bool) {
	v := m.executor
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutor returns the old "executor" field's value of the ReviewProjectDetail entity.
// If the ReviewProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewProjectDetailMutation) OldExecutor(ctx context.Context) (v *entity.Executor, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutor: %w", err)
	}
	return oldValue.Executor, nil
}

// ResetExecutor resets all changes to the "executor" field.
func (m *ReviewProjectDetailMutation) ResetExecutor() {
	m.executor = nil
}

// SetTypee sets the "typee" field.
func (m *ReviewProjectDetailMutation) SetTypee(u uint8) {
	m.typee = &u
	m.addtypee = nil
}

// Typee returns the value of the "typee" field in the mutation.
func (m *ReviewProjectDetailMutation) Typee() (r uint8, exists bool) {
	v := m.typee
	if v == nil {
		return
	}
	return *v, true
}

// OldTypee returns the old "typee" field's value of the ReviewProjectDetail entity.
// If the ReviewProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewProjectDetailMutation) OldTypee(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypee: %w", err)
	}
	return oldValue.Typee, nil
}

// AddTypee adds u to the "typee" field.
func (m *ReviewProjectDetailMutation) AddTypee(u int8) {
	if m.addtypee != nil {
		*m.addtypee += u
	} else {
		m.addtypee = &u
	}
}

// AddedTypee returns the value that was added to the "typee" field in this mutation.
func (m *ReviewProjectDetailMutation) AddedTypee() (r int8, exists bool) {
	v := m.addtypee
	if v == nil {
		return
	}
	return *v, true
}

// ResetTypee resets all changes to the "typee" field.
func (m *ReviewProjectDetailMutation) ResetTypee() {
	m.typee = nil
	m.addtypee = nil
}

// SetStatus sets the "status" field.
func (m *ReviewProjectDetailMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ReviewProjectDetailMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ReviewProjectDetail entity.
// If the ReviewProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewProjectDetailMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *ReviewProjectDetailMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ReviewProjectDetailMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ReviewProjectDetailMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *ReviewProjectDetailMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *ReviewProjectDetailMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the ReviewProjectDetail entity.
// If the ReviewProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewProjectDetailMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *ReviewProjectDetailMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *ReviewProjectDetailMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *ReviewProjectDetailMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the ReviewProjectDetail entity.
// If the ReviewProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewProjectDetailMutation) OldDeletedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ClearDeletedTime clears the value of the "deleted_time" field.
func (m *ReviewProjectDetailMutation) ClearDeletedTime() {
	m.deleted_time = nil
	m.clearedFields[reviewprojectdetail.FieldDeletedTime] = struct{}{}
}

// DeletedTimeCleared returns if the "deleted_time" field was cleared in this mutation.
func (m *ReviewProjectDetailMutation) DeletedTimeCleared() bool {
	_, ok := m.clearedFields[reviewprojectdetail.FieldDeletedTime]
	return ok
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *ReviewProjectDetailMutation) ResetDeletedTime() {
	m.deleted_time = nil
	delete(m.clearedFields, reviewprojectdetail.FieldDeletedTime)
}

// SetModifiedTime sets the "modified_time" field.
func (m *ReviewProjectDetailMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *ReviewProjectDetailMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the ReviewProjectDetail entity.
// If the ReviewProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewProjectDetailMutation) OldModifiedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ClearModifiedTime clears the value of the "modified_time" field.
func (m *ReviewProjectDetailMutation) ClearModifiedTime() {
	m.modified_time = nil
	m.clearedFields[reviewprojectdetail.FieldModifiedTime] = struct{}{}
}

// ModifiedTimeCleared returns if the "modified_time" field was cleared in this mutation.
func (m *ReviewProjectDetailMutation) ModifiedTimeCleared() bool {
	_, ok := m.clearedFields[reviewprojectdetail.FieldModifiedTime]
	return ok
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *ReviewProjectDetailMutation) ResetModifiedTime() {
	m.modified_time = nil
	delete(m.clearedFields, reviewprojectdetail.FieldModifiedTime)
}

// ClearReviewProject clears the "review_project" edge to the ReviewProject entity.
func (m *ReviewProjectDetailMutation) ClearReviewProject() {
	m.clearedreview_project = true
}

// ReviewProjectCleared reports if the "review_project" edge to the ReviewProject entity was cleared.
func (m *ReviewProjectDetailMutation) ReviewProjectCleared() bool {
	return m.clearedreview_project
}

// ReviewProjectIDs returns the "review_project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReviewProjectID instead. It exists only for internal usage by the builders.
func (m *ReviewProjectDetailMutation) ReviewProjectIDs() (ids []uint32) {
	if id := m.review_project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReviewProject resets all changes to the "review_project" edge.
func (m *ReviewProjectDetailMutation) ResetReviewProject() {
	m.review_project = nil
	m.clearedreview_project = false
}

// Where appends a list predicates to the ReviewProjectDetailMutation builder.
func (m *ReviewProjectDetailMutation) Where(ps ...predicate.ReviewProjectDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReviewProjectDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReviewProjectDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReviewProjectDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReviewProjectDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReviewProjectDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReviewProjectDetail).
func (m *ReviewProjectDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReviewProjectDetailMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.review_project != nil {
		fields = append(fields, reviewprojectdetail.FieldReviewProjectID)
	}
	if m._order != nil {
		fields = append(fields, reviewprojectdetail.FieldOrder)
	}
	if m.reviewer != nil {
		fields = append(fields, reviewprojectdetail.FieldReviewer)
	}
	if m.executor != nil {
		fields = append(fields, reviewprojectdetail.FieldExecutor)
	}
	if m.typee != nil {
		fields = append(fields, reviewprojectdetail.FieldTypee)
	}
	if m.status != nil {
		fields = append(fields, reviewprojectdetail.FieldStatus)
	}
	if m.created_time != nil {
		fields = append(fields, reviewprojectdetail.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, reviewprojectdetail.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, reviewprojectdetail.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReviewProjectDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reviewprojectdetail.FieldReviewProjectID:
		return m.ReviewProjectID()
	case reviewprojectdetail.FieldOrder:
		return m.Order()
	case reviewprojectdetail.FieldReviewer:
		return m.Reviewer()
	case reviewprojectdetail.FieldExecutor:
		return m.Executor()
	case reviewprojectdetail.FieldTypee:
		return m.Typee()
	case reviewprojectdetail.FieldStatus:
		return m.Status()
	case reviewprojectdetail.FieldCreatedTime:
		return m.CreatedTime()
	case reviewprojectdetail.FieldDeletedTime:
		return m.DeletedTime()
	case reviewprojectdetail.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReviewProjectDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reviewprojectdetail.FieldReviewProjectID:
		return m.OldReviewProjectID(ctx)
	case reviewprojectdetail.FieldOrder:
		return m.OldOrder(ctx)
	case reviewprojectdetail.FieldReviewer:
		return m.OldReviewer(ctx)
	case reviewprojectdetail.FieldExecutor:
		return m.OldExecutor(ctx)
	case reviewprojectdetail.FieldTypee:
		return m.OldTypee(ctx)
	case reviewprojectdetail.FieldStatus:
		return m.OldStatus(ctx)
	case reviewprojectdetail.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case reviewprojectdetail.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case reviewprojectdetail.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown ReviewProjectDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewProjectDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reviewprojectdetail.FieldReviewProjectID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewProjectID(v)
		return nil
	case reviewprojectdetail.FieldOrder:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case reviewprojectdetail.FieldReviewer:
		v, ok := value.(*entity.Reviewer)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewer(v)
		return nil
	case reviewprojectdetail.FieldExecutor:
		v, ok := value.(*entity.Executor)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutor(v)
		return nil
	case reviewprojectdetail.FieldTypee:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypee(v)
		return nil
	case reviewprojectdetail.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case reviewprojectdetail.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case reviewprojectdetail.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case reviewprojectdetail.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown ReviewProjectDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReviewProjectDetailMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, reviewprojectdetail.FieldOrder)
	}
	if m.addtypee != nil {
		fields = append(fields, reviewprojectdetail.FieldTypee)
	}
	if m.addstatus != nil {
		fields = append(fields, reviewprojectdetail.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReviewProjectDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case reviewprojectdetail.FieldOrder:
		return m.AddedOrder()
	case reviewprojectdetail.FieldTypee:
		return m.AddedTypee()
	case reviewprojectdetail.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewProjectDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case reviewprojectdetail.FieldOrder:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	case reviewprojectdetail.FieldTypee:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTypee(v)
		return nil
	case reviewprojectdetail.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ReviewProjectDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReviewProjectDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reviewprojectdetail.FieldDeletedTime) {
		fields = append(fields, reviewprojectdetail.FieldDeletedTime)
	}
	if m.FieldCleared(reviewprojectdetail.FieldModifiedTime) {
		fields = append(fields, reviewprojectdetail.FieldModifiedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReviewProjectDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReviewProjectDetailMutation) ClearField(name string) error {
	switch name {
	case reviewprojectdetail.FieldDeletedTime:
		m.ClearDeletedTime()
		return nil
	case reviewprojectdetail.FieldModifiedTime:
		m.ClearModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown ReviewProjectDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReviewProjectDetailMutation) ResetField(name string) error {
	switch name {
	case reviewprojectdetail.FieldReviewProjectID:
		m.ResetReviewProjectID()
		return nil
	case reviewprojectdetail.FieldOrder:
		m.ResetOrder()
		return nil
	case reviewprojectdetail.FieldReviewer:
		m.ResetReviewer()
		return nil
	case reviewprojectdetail.FieldExecutor:
		m.ResetExecutor()
		return nil
	case reviewprojectdetail.FieldTypee:
		m.ResetTypee()
		return nil
	case reviewprojectdetail.FieldStatus:
		m.ResetStatus()
		return nil
	case reviewprojectdetail.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case reviewprojectdetail.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case reviewprojectdetail.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown ReviewProjectDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReviewProjectDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.review_project != nil {
		edges = append(edges, reviewprojectdetail.EdgeReviewProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReviewProjectDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reviewprojectdetail.EdgeReviewProject:
		if id := m.review_project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReviewProjectDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReviewProjectDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReviewProjectDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedreview_project {
		edges = append(edges, reviewprojectdetail.EdgeReviewProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReviewProjectDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case reviewprojectdetail.EdgeReviewProject:
		return m.clearedreview_project
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReviewProjectDetailMutation) ClearEdge(name string) error {
	switch name {
	case reviewprojectdetail.EdgeReviewProject:
		m.ClearReviewProject()
		return nil
	}
	return fmt.Errorf("unknown ReviewProjectDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReviewProjectDetailMutation) ResetEdge(name string) error {
	switch name {
	case reviewprojectdetail.EdgeReviewProject:
		m.ResetReviewProject()
		return nil
	}
	return fmt.Errorf("unknown ReviewProjectDetail edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint8
	name               *string
	description        *string
	is_disabled        *bool
	created_time       *time.Time
	modified_time      *time.Time
	deleted_time       *time.Time
	clearedFields      map[string]struct{}
	permissions        map[uint16]struct{}
	removedpermissions map[uint16]struct{}
	clearedpermissions bool
	menu               map[uint8]struct{}
	removedmenu        map[uint8]struct{}
	clearedmenu        bool
	users              map[uint32]struct{}
	removedusers       map[uint32]struct{}
	clearedusers       bool
	done               bool
	oldValue           func(context.Context) (*Role, error)
	predicates         []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id uint8) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id uint8) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id uint8, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]uint8, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint8{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[role.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[role.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, role.FieldDescription)
}

// SetIsDisabled sets the "is_disabled" field.
func (m *RoleMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *RoleMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *RoleMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *RoleMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *RoleMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *RoleMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetModifiedTime sets the "modified_time" field.
func (m *RoleMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *RoleMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldModifiedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ClearModifiedTime clears the value of the "modified_time" field.
func (m *RoleMutation) ClearModifiedTime() {
	m.modified_time = nil
	m.clearedFields[role.FieldModifiedTime] = struct{}{}
}

// ModifiedTimeCleared returns if the "modified_time" field was cleared in this mutation.
func (m *RoleMutation) ModifiedTimeCleared() bool {
	_, ok := m.clearedFields[role.FieldModifiedTime]
	return ok
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *RoleMutation) ResetModifiedTime() {
	m.modified_time = nil
	delete(m.clearedFields, role.FieldModifiedTime)
}

// SetDeletedTime sets the "deleted_time" field.
func (m *RoleMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *RoleMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDeletedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ClearDeletedTime clears the value of the "deleted_time" field.
func (m *RoleMutation) ClearDeletedTime() {
	m.deleted_time = nil
	m.clearedFields[role.FieldDeletedTime] = struct{}{}
}

// DeletedTimeCleared returns if the "deleted_time" field was cleared in this mutation.
func (m *RoleMutation) DeletedTimeCleared() bool {
	_, ok := m.clearedFields[role.FieldDeletedTime]
	return ok
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *RoleMutation) ResetDeletedTime() {
	m.deleted_time = nil
	delete(m.clearedFields, role.FieldDeletedTime)
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *RoleMutation) AddPermissionIDs(ids ...uint16) {
	if m.permissions == nil {
		m.permissions = make(map[uint16]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *RoleMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *RoleMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *RoleMutation) RemovePermissionIDs(ids ...uint16) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[uint16]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *RoleMutation) RemovedPermissionsIDs() (ids []uint16) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *RoleMutation) PermissionsIDs() (ids []uint16) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *RoleMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddMenuIDs adds the "menu" edge to the Menu entity by ids.
func (m *RoleMutation) AddMenuIDs(ids ...uint8) {
	if m.menu == nil {
		m.menu = make(map[uint8]struct{})
	}
	for i := range ids {
		m.menu[ids[i]] = struct{}{}
	}
}

// ClearMenu clears the "menu" edge to the Menu entity.
func (m *RoleMutation) ClearMenu() {
	m.clearedmenu = true
}

// MenuCleared reports if the "menu" edge to the Menu entity was cleared.
func (m *RoleMutation) MenuCleared() bool {
	return m.clearedmenu
}

// RemoveMenuIDs removes the "menu" edge to the Menu entity by IDs.
func (m *RoleMutation) RemoveMenuIDs(ids ...uint8) {
	if m.removedmenu == nil {
		m.removedmenu = make(map[uint8]struct{})
	}
	for i := range ids {
		delete(m.menu, ids[i])
		m.removedmenu[ids[i]] = struct{}{}
	}
}

// RemovedMenu returns the removed IDs of the "menu" edge to the Menu entity.
func (m *RoleMutation) RemovedMenuIDs() (ids []uint8) {
	for id := range m.removedmenu {
		ids = append(ids, id)
	}
	return
}

// MenuIDs returns the "menu" edge IDs in the mutation.
func (m *RoleMutation) MenuIDs() (ids []uint8) {
	for id := range m.menu {
		ids = append(ids, id)
	}
	return
}

// ResetMenu resets all changes to the "menu" edge.
func (m *RoleMutation) ResetMenu() {
	m.menu = nil
	m.clearedmenu = false
	m.removedmenu = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...uint32) {
	if m.users == nil {
		m.users = make(map[uint32]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...uint32) {
	if m.removedusers == nil {
		m.removedusers = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []uint32) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []uint32) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	if m.is_disabled != nil {
		fields = append(fields, role.FieldIsDisabled)
	}
	if m.created_time != nil {
		fields = append(fields, role.FieldCreatedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, role.FieldModifiedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, role.FieldDeletedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldName:
		return m.Name()
	case role.FieldDescription:
		return m.Description()
	case role.FieldIsDisabled:
		return m.IsDisabled()
	case role.FieldCreatedTime:
		return m.CreatedTime()
	case role.FieldModifiedTime:
		return m.ModifiedTime()
	case role.FieldDeletedTime:
		return m.DeletedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	case role.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case role.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case role.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	case role.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case role.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case role.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case role.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	case role.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldDescription) {
		fields = append(fields, role.FieldDescription)
	}
	if m.FieldCleared(role.FieldModifiedTime) {
		fields = append(fields, role.FieldModifiedTime)
	}
	if m.FieldCleared(role.FieldDeletedTime) {
		fields = append(fields, role.FieldDeletedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldDescription:
		m.ClearDescription()
		return nil
	case role.FieldModifiedTime:
		m.ClearModifiedTime()
		return nil
	case role.FieldDeletedTime:
		m.ClearDeletedTime()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	case role.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case role.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case role.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	case role.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.permissions != nil {
		edges = append(edges, role.EdgePermissions)
	}
	if m.menu != nil {
		edges = append(edges, role.EdgeMenu)
	}
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeMenu:
		ids := make([]ent.Value, 0, len(m.menu))
		for id := range m.menu {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedpermissions != nil {
		edges = append(edges, role.EdgePermissions)
	}
	if m.removedmenu != nil {
		edges = append(edges, role.EdgeMenu)
	}
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeMenu:
		ids := make([]ent.Value, 0, len(m.removedmenu))
		for id := range m.removedmenu {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpermissions {
		edges = append(edges, role.EdgePermissions)
	}
	if m.clearedmenu {
		edges = append(edges, role.EdgeMenu)
	}
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgePermissions:
		return m.clearedpermissions
	case role.EdgeMenu:
		return m.clearedmenu
	case role.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgePermissions:
		m.ResetPermissions()
		return nil
	case role.EdgeMenu:
		m.ResetMenu()
		return nil
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// RolePermissionMutation represents an operation that mutates the RolePermission nodes in the graph.
type RolePermissionMutation struct {
	config
	op                Op
	typ               string
	created_time      *time.Time
	clearedFields     map[string]struct{}
	role              *uint8
	clearedrole       bool
	permission        *uint16
	clearedpermission bool
	done              bool
	oldValue          func(context.Context) (*RolePermission, error)
	predicates        []predicate.RolePermission
}

var _ ent.Mutation = (*RolePermissionMutation)(nil)

// rolepermissionOption allows management of the mutation configuration using functional options.
type rolepermissionOption func(*RolePermissionMutation)

// newRolePermissionMutation creates new mutation for the RolePermission entity.
func newRolePermissionMutation(c config, op Op, opts ...rolepermissionOption) *RolePermissionMutation {
	m := &RolePermissionMutation{
		config:        c,
		op:            op,
		typ:           TypeRolePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RolePermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RolePermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetRid sets the "rid" field.
func (m *RolePermissionMutation) SetRid(u uint8) {
	m.role = &u
}

// Rid returns the value of the "rid" field in the mutation.
func (m *RolePermissionMutation) Rid() (r uint8, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// ResetRid resets all changes to the "rid" field.
func (m *RolePermissionMutation) ResetRid() {
	m.role = nil
}

// SetPid sets the "pid" field.
func (m *RolePermissionMutation) SetPid(u uint16) {
	m.permission = &u
}

// Pid returns the value of the "pid" field in the mutation.
func (m *RolePermissionMutation) Pid() (r uint16, exists bool) {
	v := m.permission
	if v == nil {
		return
	}
	return *v, true
}

// ResetPid resets all changes to the "pid" field.
func (m *RolePermissionMutation) ResetPid() {
	m.permission = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *RolePermissionMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *RolePermissionMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *RolePermissionMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetRoleID sets the "role" edge to the Role entity by id.
func (m *RolePermissionMutation) SetRoleID(id uint8) {
	m.role = &id
}

// ClearRole clears the "role" edge to the Role entity.
func (m *RolePermissionMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *RolePermissionMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleID returns the "role" edge ID in the mutation.
func (m *RolePermissionMutation) RoleID() (id uint8, exists bool) {
	if m.role != nil {
		return *m.role, true
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *RolePermissionMutation) RoleIDs() (ids []uint8) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *RolePermissionMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// SetPermissionID sets the "permission" edge to the Permission entity by id.
func (m *RolePermissionMutation) SetPermissionID(id uint16) {
	m.permission = &id
}

// ClearPermission clears the "permission" edge to the Permission entity.
func (m *RolePermissionMutation) ClearPermission() {
	m.clearedpermission = true
}

// PermissionCleared reports if the "permission" edge to the Permission entity was cleared.
func (m *RolePermissionMutation) PermissionCleared() bool {
	return m.clearedpermission
}

// PermissionID returns the "permission" edge ID in the mutation.
func (m *RolePermissionMutation) PermissionID() (id uint16, exists bool) {
	if m.permission != nil {
		return *m.permission, true
	}
	return
}

// PermissionIDs returns the "permission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PermissionID instead. It exists only for internal usage by the builders.
func (m *RolePermissionMutation) PermissionIDs() (ids []uint16) {
	if id := m.permission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPermission resets all changes to the "permission" edge.
func (m *RolePermissionMutation) ResetPermission() {
	m.permission = nil
	m.clearedpermission = false
}

// Where appends a list predicates to the RolePermissionMutation builder.
func (m *RolePermissionMutation) Where(ps ...predicate.RolePermission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RolePermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RolePermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RolePermission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RolePermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RolePermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RolePermission).
func (m *RolePermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RolePermissionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.role != nil {
		fields = append(fields, rolepermission.FieldRid)
	}
	if m.permission != nil {
		fields = append(fields, rolepermission.FieldPid)
	}
	if m.created_time != nil {
		fields = append(fields, rolepermission.FieldCreatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RolePermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rolepermission.FieldRid:
		return m.Rid()
	case rolepermission.FieldPid:
		return m.Pid()
	case rolepermission.FieldCreatedTime:
		return m.CreatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RolePermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema RolePermission does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RolePermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rolepermission.FieldRid:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRid(v)
		return nil
	case rolepermission.FieldPid:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPid(v)
		return nil
	case rolepermission.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown RolePermission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RolePermissionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RolePermissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RolePermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RolePermission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RolePermissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RolePermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RolePermissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RolePermission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RolePermissionMutation) ResetField(name string) error {
	switch name {
	case rolepermission.FieldRid:
		m.ResetRid()
		return nil
	case rolepermission.FieldPid:
		m.ResetPid()
		return nil
	case rolepermission.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown RolePermission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RolePermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.role != nil {
		edges = append(edges, rolepermission.EdgeRole)
	}
	if m.permission != nil {
		edges = append(edges, rolepermission.EdgePermission)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RolePermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rolepermission.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	case rolepermission.EdgePermission:
		if id := m.permission; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RolePermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RolePermissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RolePermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrole {
		edges = append(edges, rolepermission.EdgeRole)
	}
	if m.clearedpermission {
		edges = append(edges, rolepermission.EdgePermission)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RolePermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case rolepermission.EdgeRole:
		return m.clearedrole
	case rolepermission.EdgePermission:
		return m.clearedpermission
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RolePermissionMutation) ClearEdge(name string) error {
	switch name {
	case rolepermission.EdgeRole:
		m.ClearRole()
		return nil
	case rolepermission.EdgePermission:
		m.ClearPermission()
		return nil
	}
	return fmt.Errorf("unknown RolePermission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RolePermissionMutation) ResetEdge(name string) error {
	switch name {
	case rolepermission.EdgeRole:
		m.ResetRole()
		return nil
	case rolepermission.EdgePermission:
		m.ResetPermission()
		return nil
	}
	return fmt.Errorf("unknown RolePermission edge %s", name)
}

// SampleFileMutation represents an operation that mutates the SampleFile nodes in the graph.
type SampleFileMutation struct {
	config
	op            Op
	typ           string
	id            *uint8
	_type         *string
	is_disabled   *bool
	created_time  *time.Time
	deleted_time  *time.Time
	modified_time *time.Time
	clearedFields map[string]struct{}
	file          *uint32
	clearedfile   bool
	done          bool
	oldValue      func(context.Context) (*SampleFile, error)
	predicates    []predicate.SampleFile
}

var _ ent.Mutation = (*SampleFileMutation)(nil)

// samplefileOption allows management of the mutation configuration using functional options.
type samplefileOption func(*SampleFileMutation)

// newSampleFileMutation creates new mutation for the SampleFile entity.
func newSampleFileMutation(c config, op Op, opts ...samplefileOption) *SampleFileMutation {
	m := &SampleFileMutation{
		config:        c,
		op:            op,
		typ:           TypeSampleFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSampleFileID sets the ID field of the mutation.
func withSampleFileID(id uint8) samplefileOption {
	return func(m *SampleFileMutation) {
		var (
			err   error
			once  sync.Once
			value *SampleFile
		)
		m.oldValue = func(ctx context.Context) (*SampleFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SampleFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSampleFile sets the old SampleFile of the mutation.
func withSampleFile(node *SampleFile) samplefileOption {
	return func(m *SampleFileMutation) {
		m.oldValue = func(context.Context) (*SampleFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SampleFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SampleFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SampleFile entities.
func (m *SampleFileMutation) SetID(id uint8) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SampleFileMutation) ID() (id uint8, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SampleFileMutation) IDs(ctx context.Context) ([]uint8, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint8{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SampleFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFid sets the "fid" field.
func (m *SampleFileMutation) SetFid(u uint32) {
	m.file = &u
}

// Fid returns the value of the "fid" field in the mutation.
func (m *SampleFileMutation) Fid() (r uint32, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFid returns the old "fid" field's value of the SampleFile entity.
// If the SampleFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleFileMutation) OldFid(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFid: %w", err)
	}
	return oldValue.Fid, nil
}

// ResetFid resets all changes to the "fid" field.
func (m *SampleFileMutation) ResetFid() {
	m.file = nil
}

// SetType sets the "type" field.
func (m *SampleFileMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SampleFileMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SampleFile entity.
// If the SampleFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleFileMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SampleFileMutation) ResetType() {
	m._type = nil
}

// SetIsDisabled sets the "is_disabled" field.
func (m *SampleFileMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *SampleFileMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the SampleFile entity.
// If the SampleFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleFileMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *SampleFileMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *SampleFileMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *SampleFileMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the SampleFile entity.
// If the SampleFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleFileMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *SampleFileMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *SampleFileMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *SampleFileMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the SampleFile entity.
// If the SampleFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleFileMutation) OldDeletedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ClearDeletedTime clears the value of the "deleted_time" field.
func (m *SampleFileMutation) ClearDeletedTime() {
	m.deleted_time = nil
	m.clearedFields[samplefile.FieldDeletedTime] = struct{}{}
}

// DeletedTimeCleared returns if the "deleted_time" field was cleared in this mutation.
func (m *SampleFileMutation) DeletedTimeCleared() bool {
	_, ok := m.clearedFields[samplefile.FieldDeletedTime]
	return ok
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *SampleFileMutation) ResetDeletedTime() {
	m.deleted_time = nil
	delete(m.clearedFields, samplefile.FieldDeletedTime)
}

// SetModifiedTime sets the "modified_time" field.
func (m *SampleFileMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *SampleFileMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the SampleFile entity.
// If the SampleFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleFileMutation) OldModifiedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ClearModifiedTime clears the value of the "modified_time" field.
func (m *SampleFileMutation) ClearModifiedTime() {
	m.modified_time = nil
	m.clearedFields[samplefile.FieldModifiedTime] = struct{}{}
}

// ModifiedTimeCleared returns if the "modified_time" field was cleared in this mutation.
func (m *SampleFileMutation) ModifiedTimeCleared() bool {
	_, ok := m.clearedFields[samplefile.FieldModifiedTime]
	return ok
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *SampleFileMutation) ResetModifiedTime() {
	m.modified_time = nil
	delete(m.clearedFields, samplefile.FieldModifiedTime)
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *SampleFileMutation) SetFileID(id uint32) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *SampleFileMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *SampleFileMutation) FileCleared() bool {
	return m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *SampleFileMutation) FileID() (id uint32, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *SampleFileMutation) FileIDs() (ids []uint32) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *SampleFileMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// Where appends a list predicates to the SampleFileMutation builder.
func (m *SampleFileMutation) Where(ps ...predicate.SampleFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SampleFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SampleFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SampleFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SampleFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SampleFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SampleFile).
func (m *SampleFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SampleFileMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.file != nil {
		fields = append(fields, samplefile.FieldFid)
	}
	if m._type != nil {
		fields = append(fields, samplefile.FieldType)
	}
	if m.is_disabled != nil {
		fields = append(fields, samplefile.FieldIsDisabled)
	}
	if m.created_time != nil {
		fields = append(fields, samplefile.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, samplefile.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, samplefile.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SampleFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case samplefile.FieldFid:
		return m.Fid()
	case samplefile.FieldType:
		return m.GetType()
	case samplefile.FieldIsDisabled:
		return m.IsDisabled()
	case samplefile.FieldCreatedTime:
		return m.CreatedTime()
	case samplefile.FieldDeletedTime:
		return m.DeletedTime()
	case samplefile.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SampleFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case samplefile.FieldFid:
		return m.OldFid(ctx)
	case samplefile.FieldType:
		return m.OldType(ctx)
	case samplefile.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case samplefile.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case samplefile.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case samplefile.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown SampleFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SampleFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case samplefile.FieldFid:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFid(v)
		return nil
	case samplefile.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case samplefile.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case samplefile.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case samplefile.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case samplefile.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown SampleFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SampleFileMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SampleFileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SampleFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SampleFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SampleFileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(samplefile.FieldDeletedTime) {
		fields = append(fields, samplefile.FieldDeletedTime)
	}
	if m.FieldCleared(samplefile.FieldModifiedTime) {
		fields = append(fields, samplefile.FieldModifiedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SampleFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SampleFileMutation) ClearField(name string) error {
	switch name {
	case samplefile.FieldDeletedTime:
		m.ClearDeletedTime()
		return nil
	case samplefile.FieldModifiedTime:
		m.ClearModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown SampleFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SampleFileMutation) ResetField(name string) error {
	switch name {
	case samplefile.FieldFid:
		m.ResetFid()
		return nil
	case samplefile.FieldType:
		m.ResetType()
		return nil
	case samplefile.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case samplefile.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case samplefile.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case samplefile.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown SampleFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SampleFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.file != nil {
		edges = append(edges, samplefile.EdgeFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SampleFileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case samplefile.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SampleFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SampleFileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SampleFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfile {
		edges = append(edges, samplefile.EdgeFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SampleFileMutation) EdgeCleared(name string) bool {
	switch name {
	case samplefile.EdgeFile:
		return m.clearedfile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SampleFileMutation) ClearEdge(name string) error {
	switch name {
	case samplefile.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown SampleFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SampleFileMutation) ResetEdge(name string) error {
	switch name {
	case samplefile.EdgeFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown SampleFile edge %s", name)
}

// SchoolMutation represents an operation that mutates the School nodes in the graph.
type SchoolMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint16
	code                 *string
	name                 *string
	location             *string
	competent_department *string
	education_level      *uint8
	addeducation_level   *int8
	remark               *string
	is_disabled          *bool
	created_time         *time.Time
	deleted_time         *time.Time
	modified_time        *time.Time
	clearedFields        map[string]struct{}
	students             map[uint32]struct{}
	removedstudents      map[uint32]struct{}
	clearedstudents      bool
	done                 bool
	oldValue             func(context.Context) (*School, error)
	predicates           []predicate.School
}

var _ ent.Mutation = (*SchoolMutation)(nil)

// schoolOption allows management of the mutation configuration using functional options.
type schoolOption func(*SchoolMutation)

// newSchoolMutation creates new mutation for the School entity.
func newSchoolMutation(c config, op Op, opts ...schoolOption) *SchoolMutation {
	m := &SchoolMutation{
		config:        c,
		op:            op,
		typ:           TypeSchool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSchoolID sets the ID field of the mutation.
func withSchoolID(id uint16) schoolOption {
	return func(m *SchoolMutation) {
		var (
			err   error
			once  sync.Once
			value *School
		)
		m.oldValue = func(ctx context.Context) (*School, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().School.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchool sets the old School of the mutation.
func withSchool(node *School) schoolOption {
	return func(m *SchoolMutation) {
		m.oldValue = func(context.Context) (*School, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SchoolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SchoolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of School entities.
func (m *SchoolMutation) SetID(id uint16) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SchoolMutation) ID() (id uint16, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SchoolMutation) IDs(ctx context.Context) ([]uint16, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint16{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().School.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *SchoolMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *SchoolMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *SchoolMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *SchoolMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SchoolMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SchoolMutation) ResetName() {
	m.name = nil
}

// SetLocation sets the "location" field.
func (m *SchoolMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *SchoolMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *SchoolMutation) ResetLocation() {
	m.location = nil
}

// SetCompetentDepartment sets the "competent_department" field.
func (m *SchoolMutation) SetCompetentDepartment(s string) {
	m.competent_department = &s
}

// CompetentDepartment returns the value of the "competent_department" field in the mutation.
func (m *SchoolMutation) CompetentDepartment() (r string, exists bool) {
	v := m.competent_department
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetentDepartment returns the old "competent_department" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldCompetentDepartment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetentDepartment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetentDepartment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetentDepartment: %w", err)
	}
	return oldValue.CompetentDepartment, nil
}

// ResetCompetentDepartment resets all changes to the "competent_department" field.
func (m *SchoolMutation) ResetCompetentDepartment() {
	m.competent_department = nil
}

// SetEducationLevel sets the "education_level" field.
func (m *SchoolMutation) SetEducationLevel(u uint8) {
	m.education_level = &u
	m.addeducation_level = nil
}

// EducationLevel returns the value of the "education_level" field in the mutation.
func (m *SchoolMutation) EducationLevel() (r uint8, exists bool) {
	v := m.education_level
	if v == nil {
		return
	}
	return *v, true
}

// OldEducationLevel returns the old "education_level" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldEducationLevel(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEducationLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEducationLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducationLevel: %w", err)
	}
	return oldValue.EducationLevel, nil
}

// AddEducationLevel adds u to the "education_level" field.
func (m *SchoolMutation) AddEducationLevel(u int8) {
	if m.addeducation_level != nil {
		*m.addeducation_level += u
	} else {
		m.addeducation_level = &u
	}
}

// AddedEducationLevel returns the value that was added to the "education_level" field in this mutation.
func (m *SchoolMutation) AddedEducationLevel() (r int8, exists bool) {
	v := m.addeducation_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetEducationLevel resets all changes to the "education_level" field.
func (m *SchoolMutation) ResetEducationLevel() {
	m.education_level = nil
	m.addeducation_level = nil
}

// SetRemark sets the "remark" field.
func (m *SchoolMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *SchoolMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *SchoolMutation) ResetRemark() {
	m.remark = nil
}

// SetIsDisabled sets the "is_disabled" field.
func (m *SchoolMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *SchoolMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *SchoolMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *SchoolMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *SchoolMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *SchoolMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *SchoolMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *SchoolMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldDeletedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ClearDeletedTime clears the value of the "deleted_time" field.
func (m *SchoolMutation) ClearDeletedTime() {
	m.deleted_time = nil
	m.clearedFields[school.FieldDeletedTime] = struct{}{}
}

// DeletedTimeCleared returns if the "deleted_time" field was cleared in this mutation.
func (m *SchoolMutation) DeletedTimeCleared() bool {
	_, ok := m.clearedFields[school.FieldDeletedTime]
	return ok
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *SchoolMutation) ResetDeletedTime() {
	m.deleted_time = nil
	delete(m.clearedFields, school.FieldDeletedTime)
}

// SetModifiedTime sets the "modified_time" field.
func (m *SchoolMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *SchoolMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldModifiedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ClearModifiedTime clears the value of the "modified_time" field.
func (m *SchoolMutation) ClearModifiedTime() {
	m.modified_time = nil
	m.clearedFields[school.FieldModifiedTime] = struct{}{}
}

// ModifiedTimeCleared returns if the "modified_time" field was cleared in this mutation.
func (m *SchoolMutation) ModifiedTimeCleared() bool {
	_, ok := m.clearedFields[school.FieldModifiedTime]
	return ok
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *SchoolMutation) ResetModifiedTime() {
	m.modified_time = nil
	delete(m.clearedFields, school.FieldModifiedTime)
}

// AddStudentIDs adds the "students" edge to the Student entity by ids.
func (m *SchoolMutation) AddStudentIDs(ids ...uint32) {
	if m.students == nil {
		m.students = make(map[uint32]struct{})
	}
	for i := range ids {
		m.students[ids[i]] = struct{}{}
	}
}

// ClearStudents clears the "students" edge to the Student entity.
func (m *SchoolMutation) ClearStudents() {
	m.clearedstudents = true
}

// StudentsCleared reports if the "students" edge to the Student entity was cleared.
func (m *SchoolMutation) StudentsCleared() bool {
	return m.clearedstudents
}

// RemoveStudentIDs removes the "students" edge to the Student entity by IDs.
func (m *SchoolMutation) RemoveStudentIDs(ids ...uint32) {
	if m.removedstudents == nil {
		m.removedstudents = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.students, ids[i])
		m.removedstudents[ids[i]] = struct{}{}
	}
}

// RemovedStudents returns the removed IDs of the "students" edge to the Student entity.
func (m *SchoolMutation) RemovedStudentsIDs() (ids []uint32) {
	for id := range m.removedstudents {
		ids = append(ids, id)
	}
	return
}

// StudentsIDs returns the "students" edge IDs in the mutation.
func (m *SchoolMutation) StudentsIDs() (ids []uint32) {
	for id := range m.students {
		ids = append(ids, id)
	}
	return
}

// ResetStudents resets all changes to the "students" edge.
func (m *SchoolMutation) ResetStudents() {
	m.students = nil
	m.clearedstudents = false
	m.removedstudents = nil
}

// Where appends a list predicates to the SchoolMutation builder.
func (m *SchoolMutation) Where(ps ...predicate.School) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SchoolMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SchoolMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.School, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SchoolMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SchoolMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (School).
func (m *SchoolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SchoolMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.code != nil {
		fields = append(fields, school.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, school.FieldName)
	}
	if m.location != nil {
		fields = append(fields, school.FieldLocation)
	}
	if m.competent_department != nil {
		fields = append(fields, school.FieldCompetentDepartment)
	}
	if m.education_level != nil {
		fields = append(fields, school.FieldEducationLevel)
	}
	if m.remark != nil {
		fields = append(fields, school.FieldRemark)
	}
	if m.is_disabled != nil {
		fields = append(fields, school.FieldIsDisabled)
	}
	if m.created_time != nil {
		fields = append(fields, school.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, school.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, school.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SchoolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case school.FieldCode:
		return m.Code()
	case school.FieldName:
		return m.Name()
	case school.FieldLocation:
		return m.Location()
	case school.FieldCompetentDepartment:
		return m.CompetentDepartment()
	case school.FieldEducationLevel:
		return m.EducationLevel()
	case school.FieldRemark:
		return m.Remark()
	case school.FieldIsDisabled:
		return m.IsDisabled()
	case school.FieldCreatedTime:
		return m.CreatedTime()
	case school.FieldDeletedTime:
		return m.DeletedTime()
	case school.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SchoolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case school.FieldCode:
		return m.OldCode(ctx)
	case school.FieldName:
		return m.OldName(ctx)
	case school.FieldLocation:
		return m.OldLocation(ctx)
	case school.FieldCompetentDepartment:
		return m.OldCompetentDepartment(ctx)
	case school.FieldEducationLevel:
		return m.OldEducationLevel(ctx)
	case school.FieldRemark:
		return m.OldRemark(ctx)
	case school.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case school.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case school.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case school.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown School field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchoolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case school.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case school.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case school.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case school.FieldCompetentDepartment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetentDepartment(v)
		return nil
	case school.FieldEducationLevel:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducationLevel(v)
		return nil
	case school.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case school.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case school.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case school.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case school.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown School field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SchoolMutation) AddedFields() []string {
	var fields []string
	if m.addeducation_level != nil {
		fields = append(fields, school.FieldEducationLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SchoolMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case school.FieldEducationLevel:
		return m.AddedEducationLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchoolMutation) AddField(name string, value ent.Value) error {
	switch name {
	case school.FieldEducationLevel:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEducationLevel(v)
		return nil
	}
	return fmt.Errorf("unknown School numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SchoolMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(school.FieldDeletedTime) {
		fields = append(fields, school.FieldDeletedTime)
	}
	if m.FieldCleared(school.FieldModifiedTime) {
		fields = append(fields, school.FieldModifiedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SchoolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SchoolMutation) ClearField(name string) error {
	switch name {
	case school.FieldDeletedTime:
		m.ClearDeletedTime()
		return nil
	case school.FieldModifiedTime:
		m.ClearModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown School nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SchoolMutation) ResetField(name string) error {
	switch name {
	case school.FieldCode:
		m.ResetCode()
		return nil
	case school.FieldName:
		m.ResetName()
		return nil
	case school.FieldLocation:
		m.ResetLocation()
		return nil
	case school.FieldCompetentDepartment:
		m.ResetCompetentDepartment()
		return nil
	case school.FieldEducationLevel:
		m.ResetEducationLevel()
		return nil
	case school.FieldRemark:
		m.ResetRemark()
		return nil
	case school.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case school.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case school.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case school.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown School field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SchoolMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.students != nil {
		edges = append(edges, school.EdgeStudents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SchoolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case school.EdgeStudents:
		ids := make([]ent.Value, 0, len(m.students))
		for id := range m.students {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SchoolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstudents != nil {
		edges = append(edges, school.EdgeStudents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SchoolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case school.EdgeStudents:
		ids := make([]ent.Value, 0, len(m.removedstudents))
		for id := range m.removedstudents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SchoolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstudents {
		edges = append(edges, school.EdgeStudents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SchoolMutation) EdgeCleared(name string) bool {
	switch name {
	case school.EdgeStudents:
		return m.clearedstudents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SchoolMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown School unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SchoolMutation) ResetEdge(name string) error {
	switch name {
	case school.EdgeStudents:
		m.ResetStudents()
		return nil
	}
	return fmt.Errorf("unknown School edge %s", name)
}

// StudentMutation represents an operation that mutates the Student nodes in the graph.
type StudentMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	student_id    *string
	name          *string
	gender        *uint8
	addgender     *int8
	is_disabled   *bool
	created_time  *time.Time
	deleted_time  *time.Time
	modified_time *time.Time
	clearedFields map[string]struct{}
	class         *uint32
	clearedclass  bool
	user          *uint32
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Student, error)
	predicates    []predicate.Student
}

var _ ent.Mutation = (*StudentMutation)(nil)

// studentOption allows management of the mutation configuration using functional options.
type studentOption func(*StudentMutation)

// newStudentMutation creates new mutation for the Student entity.
func newStudentMutation(c config, op Op, opts ...studentOption) *StudentMutation {
	m := &StudentMutation{
		config:        c,
		op:            op,
		typ:           TypeStudent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStudentID sets the ID field of the mutation.
func withStudentID(id uint32) studentOption {
	return func(m *StudentMutation) {
		var (
			err   error
			once  sync.Once
			value *Student
		)
		m.oldValue = func(ctx context.Context) (*Student, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Student.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStudent sets the old Student of the mutation.
func withStudent(node *Student) studentOption {
	return func(m *StudentMutation) {
		m.oldValue = func(context.Context) (*Student, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StudentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StudentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Student entities.
func (m *StudentMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StudentMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StudentMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Student.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *StudentMutation) SetUID(u uint32) {
	m.user = &u
}

// UID returns the value of the "uid" field in the mutation.
func (m *StudentMutation) UID() (r uint32, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldUID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ClearUID clears the value of the "uid" field.
func (m *StudentMutation) ClearUID() {
	m.user = nil
	m.clearedFields[student.FieldUID] = struct{}{}
}

// UIDCleared returns if the "uid" field was cleared in this mutation.
func (m *StudentMutation) UIDCleared() bool {
	_, ok := m.clearedFields[student.FieldUID]
	return ok
}

// ResetUID resets all changes to the "uid" field.
func (m *StudentMutation) ResetUID() {
	m.user = nil
	delete(m.clearedFields, student.FieldUID)
}

// SetCid sets the "cid" field.
func (m *StudentMutation) SetCid(u uint32) {
	m.class = &u
}

// Cid returns the value of the "cid" field in the mutation.
func (m *StudentMutation) Cid() (r uint32, exists bool) {
	v := m.class
	if v == nil {
		return
	}
	return *v, true
}

// OldCid returns the old "cid" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldCid(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCid: %w", err)
	}
	return oldValue.Cid, nil
}

// ResetCid resets all changes to the "cid" field.
func (m *StudentMutation) ResetCid() {
	m.class = nil
}

// SetStudentID sets the "student_id" field.
func (m *StudentMutation) SetStudentID(s string) {
	m.student_id = &s
}

// StudentID returns the value of the "student_id" field in the mutation.
func (m *StudentMutation) StudentID() (r string, exists bool) {
	v := m.student_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStudentID returns the old "student_id" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldStudentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStudentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStudentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStudentID: %w", err)
	}
	return oldValue.StudentID, nil
}

// ResetStudentID resets all changes to the "student_id" field.
func (m *StudentMutation) ResetStudentID() {
	m.student_id = nil
}

// SetName sets the "name" field.
func (m *StudentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StudentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StudentMutation) ResetName() {
	m.name = nil
}

// SetGender sets the "gender" field.
func (m *StudentMutation) SetGender(u uint8) {
	m.gender = &u
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *StudentMutation) Gender() (r uint8, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldGender(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds u to the "gender" field.
func (m *StudentMutation) AddGender(u int8) {
	if m.addgender != nil {
		*m.addgender += u
	} else {
		m.addgender = &u
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *StudentMutation) AddedGender() (r int8, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ResetGender resets all changes to the "gender" field.
func (m *StudentMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
}

// SetIsDisabled sets the "is_disabled" field.
func (m *StudentMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *StudentMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *StudentMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *StudentMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *StudentMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *StudentMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *StudentMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *StudentMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldDeletedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ClearDeletedTime clears the value of the "deleted_time" field.
func (m *StudentMutation) ClearDeletedTime() {
	m.deleted_time = nil
	m.clearedFields[student.FieldDeletedTime] = struct{}{}
}

// DeletedTimeCleared returns if the "deleted_time" field was cleared in this mutation.
func (m *StudentMutation) DeletedTimeCleared() bool {
	_, ok := m.clearedFields[student.FieldDeletedTime]
	return ok
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *StudentMutation) ResetDeletedTime() {
	m.deleted_time = nil
	delete(m.clearedFields, student.FieldDeletedTime)
}

// SetModifiedTime sets the "modified_time" field.
func (m *StudentMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *StudentMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldModifiedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ClearModifiedTime clears the value of the "modified_time" field.
func (m *StudentMutation) ClearModifiedTime() {
	m.modified_time = nil
	m.clearedFields[student.FieldModifiedTime] = struct{}{}
}

// ModifiedTimeCleared returns if the "modified_time" field was cleared in this mutation.
func (m *StudentMutation) ModifiedTimeCleared() bool {
	_, ok := m.clearedFields[student.FieldModifiedTime]
	return ok
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *StudentMutation) ResetModifiedTime() {
	m.modified_time = nil
	delete(m.clearedFields, student.FieldModifiedTime)
}

// SetClassID sets the "class" edge to the Class entity by id.
func (m *StudentMutation) SetClassID(id uint32) {
	m.class = &id
}

// ClearClass clears the "class" edge to the Class entity.
func (m *StudentMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *StudentMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *StudentMutation) ClassID() (id uint32, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) ClassIDs() (ids []uint32) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *StudentMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *StudentMutation) SetUserID(id uint32) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *StudentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *StudentMutation) UserCleared() bool {
	return m.UIDCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *StudentMutation) UserID() (id uint32, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) UserIDs() (ids []uint32) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *StudentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the StudentMutation builder.
func (m *StudentMutation) Where(ps ...predicate.Student) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StudentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StudentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Student, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StudentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StudentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Student).
func (m *StudentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StudentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.user != nil {
		fields = append(fields, student.FieldUID)
	}
	if m.class != nil {
		fields = append(fields, student.FieldCid)
	}
	if m.student_id != nil {
		fields = append(fields, student.FieldStudentID)
	}
	if m.name != nil {
		fields = append(fields, student.FieldName)
	}
	if m.gender != nil {
		fields = append(fields, student.FieldGender)
	}
	if m.is_disabled != nil {
		fields = append(fields, student.FieldIsDisabled)
	}
	if m.created_time != nil {
		fields = append(fields, student.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, student.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, student.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StudentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case student.FieldUID:
		return m.UID()
	case student.FieldCid:
		return m.Cid()
	case student.FieldStudentID:
		return m.StudentID()
	case student.FieldName:
		return m.Name()
	case student.FieldGender:
		return m.Gender()
	case student.FieldIsDisabled:
		return m.IsDisabled()
	case student.FieldCreatedTime:
		return m.CreatedTime()
	case student.FieldDeletedTime:
		return m.DeletedTime()
	case student.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StudentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case student.FieldUID:
		return m.OldUID(ctx)
	case student.FieldCid:
		return m.OldCid(ctx)
	case student.FieldStudentID:
		return m.OldStudentID(ctx)
	case student.FieldName:
		return m.OldName(ctx)
	case student.FieldGender:
		return m.OldGender(ctx)
	case student.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case student.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case student.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case student.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Student field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case student.FieldUID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case student.FieldCid:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCid(v)
		return nil
	case student.FieldStudentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStudentID(v)
		return nil
	case student.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case student.FieldGender:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case student.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case student.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case student.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case student.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StudentMutation) AddedFields() []string {
	var fields []string
	if m.addgender != nil {
		fields = append(fields, student.FieldGender)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StudentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case student.FieldGender:
		return m.AddedGender()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case student.FieldGender:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	}
	return fmt.Errorf("unknown Student numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StudentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(student.FieldUID) {
		fields = append(fields, student.FieldUID)
	}
	if m.FieldCleared(student.FieldDeletedTime) {
		fields = append(fields, student.FieldDeletedTime)
	}
	if m.FieldCleared(student.FieldModifiedTime) {
		fields = append(fields, student.FieldModifiedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StudentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StudentMutation) ClearField(name string) error {
	switch name {
	case student.FieldUID:
		m.ClearUID()
		return nil
	case student.FieldDeletedTime:
		m.ClearDeletedTime()
		return nil
	case student.FieldModifiedTime:
		m.ClearModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown Student nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StudentMutation) ResetField(name string) error {
	switch name {
	case student.FieldUID:
		m.ResetUID()
		return nil
	case student.FieldCid:
		m.ResetCid()
		return nil
	case student.FieldStudentID:
		m.ResetStudentID()
		return nil
	case student.FieldName:
		m.ResetName()
		return nil
	case student.FieldGender:
		m.ResetGender()
		return nil
	case student.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case student.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case student.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case student.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StudentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.class != nil {
		edges = append(edges, student.EdgeClass)
	}
	if m.user != nil {
		edges = append(edges, student.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StudentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	case student.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StudentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StudentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StudentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedclass {
		edges = append(edges, student.EdgeClass)
	}
	if m.cleareduser {
		edges = append(edges, student.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StudentMutation) EdgeCleared(name string) bool {
	switch name {
	case student.EdgeClass:
		return m.clearedclass
	case student.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StudentMutation) ClearEdge(name string) error {
	switch name {
	case student.EdgeClass:
		m.ClearClass()
		return nil
	case student.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Student unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StudentMutation) ResetEdge(name string) error {
	switch name {
	case student.EdgeClass:
		m.ResetClass()
		return nil
	case student.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Student edge %s", name)
}

// TeacherMutation represents an operation that mutates the Teacher nodes in the graph.
type TeacherMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	teacher_id     *string
	name           *string
	gender         *uint8
	addgender      *int8
	is_disabled    *bool
	created_time   *time.Time
	deleted_time   *time.Time
	modified_time  *time.Time
	clearedFields  map[string]struct{}
	college        *uint8
	clearedcollege bool
	user           *uint32
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Teacher, error)
	predicates     []predicate.Teacher
}

var _ ent.Mutation = (*TeacherMutation)(nil)

// teacherOption allows management of the mutation configuration using functional options.
type teacherOption func(*TeacherMutation)

// newTeacherMutation creates new mutation for the Teacher entity.
func newTeacherMutation(c config, op Op, opts ...teacherOption) *TeacherMutation {
	m := &TeacherMutation{
		config:        c,
		op:            op,
		typ:           TypeTeacher,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeacherID sets the ID field of the mutation.
func withTeacherID(id uint32) teacherOption {
	return func(m *TeacherMutation) {
		var (
			err   error
			once  sync.Once
			value *Teacher
		)
		m.oldValue = func(ctx context.Context) (*Teacher, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Teacher.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeacher sets the old Teacher of the mutation.
func withTeacher(node *Teacher) teacherOption {
	return func(m *TeacherMutation) {
		m.oldValue = func(context.Context) (*Teacher, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeacherMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeacherMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Teacher entities.
func (m *TeacherMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeacherMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeacherMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Teacher.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *TeacherMutation) SetUID(u uint32) {
	m.user = &u
}

// UID returns the value of the "uid" field in the mutation.
func (m *TeacherMutation) UID() (r uint32, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldUID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ClearUID clears the value of the "uid" field.
func (m *TeacherMutation) ClearUID() {
	m.user = nil
	m.clearedFields[teacher.FieldUID] = struct{}{}
}

// UIDCleared returns if the "uid" field was cleared in this mutation.
func (m *TeacherMutation) UIDCleared() bool {
	_, ok := m.clearedFields[teacher.FieldUID]
	return ok
}

// ResetUID resets all changes to the "uid" field.
func (m *TeacherMutation) ResetUID() {
	m.user = nil
	delete(m.clearedFields, teacher.FieldUID)
}

// SetCid sets the "cid" field.
func (m *TeacherMutation) SetCid(u uint8) {
	m.college = &u
}

// Cid returns the value of the "cid" field in the mutation.
func (m *TeacherMutation) Cid() (r uint8, exists bool) {
	v := m.college
	if v == nil {
		return
	}
	return *v, true
}

// OldCid returns the old "cid" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldCid(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCid: %w", err)
	}
	return oldValue.Cid, nil
}

// ResetCid resets all changes to the "cid" field.
func (m *TeacherMutation) ResetCid() {
	m.college = nil
}

// SetTeacherID sets the "teacher_id" field.
func (m *TeacherMutation) SetTeacherID(s string) {
	m.teacher_id = &s
}

// TeacherID returns the value of the "teacher_id" field in the mutation.
func (m *TeacherMutation) TeacherID() (r string, exists bool) {
	v := m.teacher_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTeacherID returns the old "teacher_id" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldTeacherID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeacherID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeacherID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeacherID: %w", err)
	}
	return oldValue.TeacherID, nil
}

// ResetTeacherID resets all changes to the "teacher_id" field.
func (m *TeacherMutation) ResetTeacherID() {
	m.teacher_id = nil
}

// SetName sets the "name" field.
func (m *TeacherMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeacherMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeacherMutation) ResetName() {
	m.name = nil
}

// SetGender sets the "gender" field.
func (m *TeacherMutation) SetGender(u uint8) {
	m.gender = &u
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *TeacherMutation) Gender() (r uint8, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldGender(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds u to the "gender" field.
func (m *TeacherMutation) AddGender(u int8) {
	if m.addgender != nil {
		*m.addgender += u
	} else {
		m.addgender = &u
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *TeacherMutation) AddedGender() (r int8, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ResetGender resets all changes to the "gender" field.
func (m *TeacherMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
}

// SetIsDisabled sets the "is_disabled" field.
func (m *TeacherMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *TeacherMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *TeacherMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *TeacherMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *TeacherMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *TeacherMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *TeacherMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *TeacherMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldDeletedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ClearDeletedTime clears the value of the "deleted_time" field.
func (m *TeacherMutation) ClearDeletedTime() {
	m.deleted_time = nil
	m.clearedFields[teacher.FieldDeletedTime] = struct{}{}
}

// DeletedTimeCleared returns if the "deleted_time" field was cleared in this mutation.
func (m *TeacherMutation) DeletedTimeCleared() bool {
	_, ok := m.clearedFields[teacher.FieldDeletedTime]
	return ok
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *TeacherMutation) ResetDeletedTime() {
	m.deleted_time = nil
	delete(m.clearedFields, teacher.FieldDeletedTime)
}

// SetModifiedTime sets the "modified_time" field.
func (m *TeacherMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *TeacherMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldModifiedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ClearModifiedTime clears the value of the "modified_time" field.
func (m *TeacherMutation) ClearModifiedTime() {
	m.modified_time = nil
	m.clearedFields[teacher.FieldModifiedTime] = struct{}{}
}

// ModifiedTimeCleared returns if the "modified_time" field was cleared in this mutation.
func (m *TeacherMutation) ModifiedTimeCleared() bool {
	_, ok := m.clearedFields[teacher.FieldModifiedTime]
	return ok
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *TeacherMutation) ResetModifiedTime() {
	m.modified_time = nil
	delete(m.clearedFields, teacher.FieldModifiedTime)
}

// SetCollegeID sets the "college" edge to the College entity by id.
func (m *TeacherMutation) SetCollegeID(id uint8) {
	m.college = &id
}

// ClearCollege clears the "college" edge to the College entity.
func (m *TeacherMutation) ClearCollege() {
	m.clearedcollege = true
}

// CollegeCleared reports if the "college" edge to the College entity was cleared.
func (m *TeacherMutation) CollegeCleared() bool {
	return m.clearedcollege
}

// CollegeID returns the "college" edge ID in the mutation.
func (m *TeacherMutation) CollegeID() (id uint8, exists bool) {
	if m.college != nil {
		return *m.college, true
	}
	return
}

// CollegeIDs returns the "college" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CollegeID instead. It exists only for internal usage by the builders.
func (m *TeacherMutation) CollegeIDs() (ids []uint8) {
	if id := m.college; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCollege resets all changes to the "college" edge.
func (m *TeacherMutation) ResetCollege() {
	m.college = nil
	m.clearedcollege = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *TeacherMutation) SetUserID(id uint32) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *TeacherMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TeacherMutation) UserCleared() bool {
	return m.UIDCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *TeacherMutation) UserID() (id uint32, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TeacherMutation) UserIDs() (ids []uint32) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TeacherMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TeacherMutation builder.
func (m *TeacherMutation) Where(ps ...predicate.Teacher) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeacherMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeacherMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Teacher, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeacherMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeacherMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Teacher).
func (m *TeacherMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeacherMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.user != nil {
		fields = append(fields, teacher.FieldUID)
	}
	if m.college != nil {
		fields = append(fields, teacher.FieldCid)
	}
	if m.teacher_id != nil {
		fields = append(fields, teacher.FieldTeacherID)
	}
	if m.name != nil {
		fields = append(fields, teacher.FieldName)
	}
	if m.gender != nil {
		fields = append(fields, teacher.FieldGender)
	}
	if m.is_disabled != nil {
		fields = append(fields, teacher.FieldIsDisabled)
	}
	if m.created_time != nil {
		fields = append(fields, teacher.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, teacher.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, teacher.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeacherMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teacher.FieldUID:
		return m.UID()
	case teacher.FieldCid:
		return m.Cid()
	case teacher.FieldTeacherID:
		return m.TeacherID()
	case teacher.FieldName:
		return m.Name()
	case teacher.FieldGender:
		return m.Gender()
	case teacher.FieldIsDisabled:
		return m.IsDisabled()
	case teacher.FieldCreatedTime:
		return m.CreatedTime()
	case teacher.FieldDeletedTime:
		return m.DeletedTime()
	case teacher.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeacherMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teacher.FieldUID:
		return m.OldUID(ctx)
	case teacher.FieldCid:
		return m.OldCid(ctx)
	case teacher.FieldTeacherID:
		return m.OldTeacherID(ctx)
	case teacher.FieldName:
		return m.OldName(ctx)
	case teacher.FieldGender:
		return m.OldGender(ctx)
	case teacher.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case teacher.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case teacher.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case teacher.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Teacher field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeacherMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teacher.FieldUID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case teacher.FieldCid:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCid(v)
		return nil
	case teacher.FieldTeacherID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeacherID(v)
		return nil
	case teacher.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case teacher.FieldGender:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case teacher.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case teacher.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case teacher.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case teacher.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Teacher field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeacherMutation) AddedFields() []string {
	var fields []string
	if m.addgender != nil {
		fields = append(fields, teacher.FieldGender)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeacherMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case teacher.FieldGender:
		return m.AddedGender()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeacherMutation) AddField(name string, value ent.Value) error {
	switch name {
	case teacher.FieldGender:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	}
	return fmt.Errorf("unknown Teacher numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeacherMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(teacher.FieldUID) {
		fields = append(fields, teacher.FieldUID)
	}
	if m.FieldCleared(teacher.FieldDeletedTime) {
		fields = append(fields, teacher.FieldDeletedTime)
	}
	if m.FieldCleared(teacher.FieldModifiedTime) {
		fields = append(fields, teacher.FieldModifiedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeacherMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeacherMutation) ClearField(name string) error {
	switch name {
	case teacher.FieldUID:
		m.ClearUID()
		return nil
	case teacher.FieldDeletedTime:
		m.ClearDeletedTime()
		return nil
	case teacher.FieldModifiedTime:
		m.ClearModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown Teacher nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeacherMutation) ResetField(name string) error {
	switch name {
	case teacher.FieldUID:
		m.ResetUID()
		return nil
	case teacher.FieldCid:
		m.ResetCid()
		return nil
	case teacher.FieldTeacherID:
		m.ResetTeacherID()
		return nil
	case teacher.FieldName:
		m.ResetName()
		return nil
	case teacher.FieldGender:
		m.ResetGender()
		return nil
	case teacher.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case teacher.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case teacher.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case teacher.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown Teacher field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeacherMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.college != nil {
		edges = append(edges, teacher.EdgeCollege)
	}
	if m.user != nil {
		edges = append(edges, teacher.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeacherMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teacher.EdgeCollege:
		if id := m.college; id != nil {
			return []ent.Value{*id}
		}
	case teacher.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeacherMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeacherMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeacherMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcollege {
		edges = append(edges, teacher.EdgeCollege)
	}
	if m.cleareduser {
		edges = append(edges, teacher.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeacherMutation) EdgeCleared(name string) bool {
	switch name {
	case teacher.EdgeCollege:
		return m.clearedcollege
	case teacher.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeacherMutation) ClearEdge(name string) error {
	switch name {
	case teacher.EdgeCollege:
		m.ClearCollege()
		return nil
	case teacher.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Teacher unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeacherMutation) ResetEdge(name string) error {
	switch name {
	case teacher.EdgeCollege:
		m.ResetCollege()
		return nil
	case teacher.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Teacher edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint32
	account               *string
	password              *string
	username              *string
	email                 *string
	phone                 *string
	introduction          *string
	is_disabled           *bool
	created_time          *time.Time
	deleted_time          *time.Time
	modified_time         *time.Time
	clearedFields         map[string]struct{}
	roles                 map[uint8]struct{}
	removedroles          map[uint8]struct{}
	clearedroles          bool
	student               *uint32
	clearedstudent        bool
	teacher               *uint32
	clearedteacher        bool
	files                 map[uint32]struct{}
	removedfiles          map[uint32]struct{}
	clearedfiles          bool
	projects              map[uint32]struct{}
	removedprojects       map[uint32]struct{}
	clearedprojects       bool
	review_project        map[uint32]struct{}
	removedreview_project map[uint32]struct{}
	clearedreview_project bool
	done                  bool
	oldValue              func(context.Context) (*User, error)
	predicates            []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uint32) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAccount sets the "account" field.
func (m *UserMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *UserMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *UserMutation) ResetAccount() {
	m.account = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *UserMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[user.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *UserMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[user.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, user.FieldUsername)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetIntroduction sets the "introduction" field.
func (m *UserMutation) SetIntroduction(s string) {
	m.introduction = &s
}

// Introduction returns the value of the "introduction" field in the mutation.
func (m *UserMutation) Introduction() (r string, exists bool) {
	v := m.introduction
	if v == nil {
		return
	}
	return *v, true
}

// OldIntroduction returns the old "introduction" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIntroduction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntroduction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntroduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntroduction: %w", err)
	}
	return oldValue.Introduction, nil
}

// ClearIntroduction clears the value of the "introduction" field.
func (m *UserMutation) ClearIntroduction() {
	m.introduction = nil
	m.clearedFields[user.FieldIntroduction] = struct{}{}
}

// IntroductionCleared returns if the "introduction" field was cleared in this mutation.
func (m *UserMutation) IntroductionCleared() bool {
	_, ok := m.clearedFields[user.FieldIntroduction]
	return ok
}

// ResetIntroduction resets all changes to the "introduction" field.
func (m *UserMutation) ResetIntroduction() {
	m.introduction = nil
	delete(m.clearedFields, user.FieldIntroduction)
}

// SetIsDisabled sets the "is_disabled" field.
func (m *UserMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *UserMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *UserMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *UserMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *UserMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *UserMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *UserMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *UserMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ClearDeletedTime clears the value of the "deleted_time" field.
func (m *UserMutation) ClearDeletedTime() {
	m.deleted_time = nil
	m.clearedFields[user.FieldDeletedTime] = struct{}{}
}

// DeletedTimeCleared returns if the "deleted_time" field was cleared in this mutation.
func (m *UserMutation) DeletedTimeCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedTime]
	return ok
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *UserMutation) ResetDeletedTime() {
	m.deleted_time = nil
	delete(m.clearedFields, user.FieldDeletedTime)
}

// SetModifiedTime sets the "modified_time" field.
func (m *UserMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *UserMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldModifiedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ClearModifiedTime clears the value of the "modified_time" field.
func (m *UserMutation) ClearModifiedTime() {
	m.modified_time = nil
	m.clearedFields[user.FieldModifiedTime] = struct{}{}
}

// ModifiedTimeCleared returns if the "modified_time" field was cleared in this mutation.
func (m *UserMutation) ModifiedTimeCleared() bool {
	_, ok := m.clearedFields[user.FieldModifiedTime]
	return ok
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *UserMutation) ResetModifiedTime() {
	m.modified_time = nil
	delete(m.clearedFields, user.FieldModifiedTime)
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *UserMutation) AddRoleIDs(ids ...uint8) {
	if m.roles == nil {
		m.roles = make(map[uint8]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *UserMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *UserMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *UserMutation) RemoveRoleIDs(ids ...uint8) {
	if m.removedroles == nil {
		m.removedroles = make(map[uint8]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *UserMutation) RemovedRolesIDs() (ids []uint8) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *UserMutation) RolesIDs() (ids []uint8) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// SetStudentID sets the "student" edge to the Student entity by id.
func (m *UserMutation) SetStudentID(id uint32) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *UserMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *UserMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *UserMutation) StudentID() (id uint32, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *UserMutation) StudentIDs() (ids []uint32) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *UserMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// SetTeacherID sets the "teacher" edge to the Teacher entity by id.
func (m *UserMutation) SetTeacherID(id uint32) {
	m.teacher = &id
}

// ClearTeacher clears the "teacher" edge to the Teacher entity.
func (m *UserMutation) ClearTeacher() {
	m.clearedteacher = true
}

// TeacherCleared reports if the "teacher" edge to the Teacher entity was cleared.
func (m *UserMutation) TeacherCleared() bool {
	return m.clearedteacher
}

// TeacherID returns the "teacher" edge ID in the mutation.
func (m *UserMutation) TeacherID() (id uint32, exists bool) {
	if m.teacher != nil {
		return *m.teacher, true
	}
	return
}

// TeacherIDs returns the "teacher" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeacherID instead. It exists only for internal usage by the builders.
func (m *UserMutation) TeacherIDs() (ids []uint32) {
	if id := m.teacher; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeacher resets all changes to the "teacher" edge.
func (m *UserMutation) ResetTeacher() {
	m.teacher = nil
	m.clearedteacher = false
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *UserMutation) AddFileIDs(ids ...uint32) {
	if m.files == nil {
		m.files = make(map[uint32]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *UserMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *UserMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *UserMutation) RemoveFileIDs(ids ...uint32) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *UserMutation) RemovedFilesIDs() (ids []uint32) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *UserMutation) FilesIDs() (ids []uint32) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *UserMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *UserMutation) AddProjectIDs(ids ...uint32) {
	if m.projects == nil {
		m.projects = make(map[uint32]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *UserMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *UserMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *UserMutation) RemoveProjectIDs(ids ...uint32) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *UserMutation) RemovedProjectsIDs() (ids []uint32) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *UserMutation) ProjectsIDs() (ids []uint32) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *UserMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddReviewProjectIDs adds the "review_project" edge to the ReviewProject entity by ids.
func (m *UserMutation) AddReviewProjectIDs(ids ...uint32) {
	if m.review_project == nil {
		m.review_project = make(map[uint32]struct{})
	}
	for i := range ids {
		m.review_project[ids[i]] = struct{}{}
	}
}

// ClearReviewProject clears the "review_project" edge to the ReviewProject entity.
func (m *UserMutation) ClearReviewProject() {
	m.clearedreview_project = true
}

// ReviewProjectCleared reports if the "review_project" edge to the ReviewProject entity was cleared.
func (m *UserMutation) ReviewProjectCleared() bool {
	return m.clearedreview_project
}

// RemoveReviewProjectIDs removes the "review_project" edge to the ReviewProject entity by IDs.
func (m *UserMutation) RemoveReviewProjectIDs(ids ...uint32) {
	if m.removedreview_project == nil {
		m.removedreview_project = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.review_project, ids[i])
		m.removedreview_project[ids[i]] = struct{}{}
	}
}

// RemovedReviewProject returns the removed IDs of the "review_project" edge to the ReviewProject entity.
func (m *UserMutation) RemovedReviewProjectIDs() (ids []uint32) {
	for id := range m.removedreview_project {
		ids = append(ids, id)
	}
	return
}

// ReviewProjectIDs returns the "review_project" edge IDs in the mutation.
func (m *UserMutation) ReviewProjectIDs() (ids []uint32) {
	for id := range m.review_project {
		ids = append(ids, id)
	}
	return
}

// ResetReviewProject resets all changes to the "review_project" edge.
func (m *UserMutation) ResetReviewProject() {
	m.review_project = nil
	m.clearedreview_project = false
	m.removedreview_project = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.account != nil {
		fields = append(fields, user.FieldAccount)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.introduction != nil {
		fields = append(fields, user.FieldIntroduction)
	}
	if m.is_disabled != nil {
		fields = append(fields, user.FieldIsDisabled)
	}
	if m.created_time != nil {
		fields = append(fields, user.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, user.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, user.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldAccount:
		return m.Account()
	case user.FieldPassword:
		return m.Password()
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldIntroduction:
		return m.Introduction()
	case user.FieldIsDisabled:
		return m.IsDisabled()
	case user.FieldCreatedTime:
		return m.CreatedTime()
	case user.FieldDeletedTime:
		return m.DeletedTime()
	case user.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldAccount:
		return m.OldAccount(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldIntroduction:
		return m.OldIntroduction(ctx)
	case user.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case user.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case user.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case user.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldIntroduction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntroduction(v)
		return nil
	case user.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case user.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case user.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case user.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldUsername) {
		fields = append(fields, user.FieldUsername)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	if m.FieldCleared(user.FieldIntroduction) {
		fields = append(fields, user.FieldIntroduction)
	}
	if m.FieldCleared(user.FieldDeletedTime) {
		fields = append(fields, user.FieldDeletedTime)
	}
	if m.FieldCleared(user.FieldModifiedTime) {
		fields = append(fields, user.FieldModifiedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ClearUsername()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	case user.FieldIntroduction:
		m.ClearIntroduction()
		return nil
	case user.FieldDeletedTime:
		m.ClearDeletedTime()
		return nil
	case user.FieldModifiedTime:
		m.ClearModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldAccount:
		m.ResetAccount()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldIntroduction:
		m.ResetIntroduction()
		return nil
	case user.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case user.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case user.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case user.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.roles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.student != nil {
		edges = append(edges, user.EdgeStudent)
	}
	if m.teacher != nil {
		edges = append(edges, user.EdgeTeacher)
	}
	if m.files != nil {
		edges = append(edges, user.EdgeFiles)
	}
	if m.projects != nil {
		edges = append(edges, user.EdgeProjects)
	}
	if m.review_project != nil {
		edges = append(edges, user.EdgeReviewProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeTeacher:
		if id := m.teacher; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReviewProject:
		ids := make([]ent.Value, 0, len(m.review_project))
		for id := range m.review_project {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedroles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.removedfiles != nil {
		edges = append(edges, user.EdgeFiles)
	}
	if m.removedprojects != nil {
		edges = append(edges, user.EdgeProjects)
	}
	if m.removedreview_project != nil {
		edges = append(edges, user.EdgeReviewProject)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReviewProject:
		ids := make([]ent.Value, 0, len(m.removedreview_project))
		for id := range m.removedreview_project {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedroles {
		edges = append(edges, user.EdgeRoles)
	}
	if m.clearedstudent {
		edges = append(edges, user.EdgeStudent)
	}
	if m.clearedteacher {
		edges = append(edges, user.EdgeTeacher)
	}
	if m.clearedfiles {
		edges = append(edges, user.EdgeFiles)
	}
	if m.clearedprojects {
		edges = append(edges, user.EdgeProjects)
	}
	if m.clearedreview_project {
		edges = append(edges, user.EdgeReviewProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRoles:
		return m.clearedroles
	case user.EdgeStudent:
		return m.clearedstudent
	case user.EdgeTeacher:
		return m.clearedteacher
	case user.EdgeFiles:
		return m.clearedfiles
	case user.EdgeProjects:
		return m.clearedprojects
	case user.EdgeReviewProject:
		return m.clearedreview_project
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeStudent:
		m.ClearStudent()
		return nil
	case user.EdgeTeacher:
		m.ClearTeacher()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeRoles:
		m.ResetRoles()
		return nil
	case user.EdgeStudent:
		m.ResetStudent()
		return nil
	case user.EdgeTeacher:
		m.ResetTeacher()
		return nil
	case user.EdgeFiles:
		m.ResetFiles()
		return nil
	case user.EdgeProjects:
		m.ResetProjects()
		return nil
	case user.EdgeReviewProject:
		m.ResetReviewProject()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserRoleMutation represents an operation that mutates the UserRole nodes in the graph.
type UserRoleMutation struct {
	config
	op            Op
	typ           string
	created_time  *time.Time
	clearedFields map[string]struct{}
	user          *uint32
	cleareduser   bool
	role          *uint8
	clearedrole   bool
	done          bool
	oldValue      func(context.Context) (*UserRole, error)
	predicates    []predicate.UserRole
}

var _ ent.Mutation = (*UserRoleMutation)(nil)

// userroleOption allows management of the mutation configuration using functional options.
type userroleOption func(*UserRoleMutation)

// newUserRoleMutation creates new mutation for the UserRole entity.
func newUserRoleMutation(c config, op Op, opts ...userroleOption) *UserRoleMutation {
	m := &UserRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeUserRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUID sets the "uid" field.
func (m *UserRoleMutation) SetUID(u uint32) {
	m.user = &u
}

// UID returns the value of the "uid" field in the mutation.
func (m *UserRoleMutation) UID() (r uint32, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUID resets all changes to the "uid" field.
func (m *UserRoleMutation) ResetUID() {
	m.user = nil
}

// SetRid sets the "rid" field.
func (m *UserRoleMutation) SetRid(u uint8) {
	m.role = &u
}

// Rid returns the value of the "rid" field in the mutation.
func (m *UserRoleMutation) Rid() (r uint8, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// ResetRid resets all changes to the "rid" field.
func (m *UserRoleMutation) ResetRid() {
	m.role = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *UserRoleMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *UserRoleMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *UserRoleMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserRoleMutation) SetUserID(id uint32) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserRoleMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserRoleMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserRoleMutation) UserID() (id uint32, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) UserIDs() (ids []uint32) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserRoleMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetRoleID sets the "role" edge to the Role entity by id.
func (m *UserRoleMutation) SetRoleID(id uint8) {
	m.role = &id
}

// ClearRole clears the "role" edge to the Role entity.
func (m *UserRoleMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *UserRoleMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleID returns the "role" edge ID in the mutation.
func (m *UserRoleMutation) RoleID() (id uint8, exists bool) {
	if m.role != nil {
		return *m.role, true
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) RoleIDs() (ids []uint8) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *UserRoleMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the UserRoleMutation builder.
func (m *UserRoleMutation) Where(ps ...predicate.UserRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserRole).
func (m *UserRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserRoleMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, userrole.FieldUID)
	}
	if m.role != nil {
		fields = append(fields, userrole.FieldRid)
	}
	if m.created_time != nil {
		fields = append(fields, userrole.FieldCreatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldUID:
		return m.UID()
	case userrole.FieldRid:
		return m.Rid()
	case userrole.FieldCreatedTime:
		return m.CreatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserRole does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldUID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case userrole.FieldRid:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRid(v)
		return nil
	case userrole.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserRoleMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserRoleMutation) ResetField(name string) error {
	switch name {
	case userrole.FieldUID:
		m.ResetUID()
		return nil
	case userrole.FieldRid:
		m.ResetRid()
		return nil
	case userrole.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userrole.EdgeUser)
	}
	if m.role != nil {
		edges = append(edges, userrole.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userrole.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userrole.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userrole.EdgeUser)
	}
	if m.clearedrole {
		edges = append(edges, userrole.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case userrole.EdgeUser:
		return m.cleareduser
	case userrole.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserRoleMutation) ClearEdge(name string) error {
	switch name {
	case userrole.EdgeUser:
		m.ClearUser()
		return nil
	case userrole.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown UserRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserRoleMutation) ResetEdge(name string) error {
	switch name {
	case userrole.EdgeUser:
		m.ResetUser()
		return nil
	case userrole.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown UserRole edge %s", name)
}
