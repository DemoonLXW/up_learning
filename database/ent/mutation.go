// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/DemoonLXW/up_learning/database/ent/class"
	"github.com/DemoonLXW/up_learning/database/ent/college"
	"github.com/DemoonLXW/up_learning/database/ent/file"
	"github.com/DemoonLXW/up_learning/database/ent/menu"
	"github.com/DemoonLXW/up_learning/database/ent/permission"
	"github.com/DemoonLXW/up_learning/database/ent/predicate"
	"github.com/DemoonLXW/up_learning/database/ent/role"
	"github.com/DemoonLXW/up_learning/database/ent/rolepermission"
	"github.com/DemoonLXW/up_learning/database/ent/samplefile"
	"github.com/DemoonLXW/up_learning/database/ent/school"
	"github.com/DemoonLXW/up_learning/database/ent/student"
	"github.com/DemoonLXW/up_learning/database/ent/user"
	"github.com/DemoonLXW/up_learning/database/ent/userrole"
	"github.com/DemoonLXW/up_learning/entity"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeClass          = "Class"
	TypeCollege        = "College"
	TypeFile           = "File"
	TypeMenu           = "Menu"
	TypePermission     = "Permission"
	TypeRole           = "Role"
	TypeRolePermission = "RolePermission"
	TypeSampleFile     = "SampleFile"
	TypeSchool         = "School"
	TypeStudent        = "Student"
	TypeUser           = "User"
	TypeUserRole       = "UserRole"
)

// ClassMutation represents an operation that mutates the Class nodes in the graph.
type ClassMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	name            *string
	is_disabled     *bool
	created_time    *time.Time
	deleted_time    *time.Time
	modified_time   *time.Time
	clearedFields   map[string]struct{}
	college         *uint16
	clearedcollege  bool
	students        map[uint32]struct{}
	removedstudents map[uint32]struct{}
	clearedstudents bool
	done            bool
	oldValue        func(context.Context) (*Class, error)
	predicates      []predicate.Class
}

var _ ent.Mutation = (*ClassMutation)(nil)

// classOption allows management of the mutation configuration using functional options.
type classOption func(*ClassMutation)

// newClassMutation creates new mutation for the Class entity.
func newClassMutation(c config, op Op, opts ...classOption) *ClassMutation {
	m := &ClassMutation{
		config:        c,
		op:            op,
		typ:           TypeClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassID sets the ID field of the mutation.
func withClassID(id uint32) classOption {
	return func(m *ClassMutation) {
		var (
			err   error
			once  sync.Once
			value *Class
		)
		m.oldValue = func(ctx context.Context) (*Class, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Class.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClass sets the old Class of the mutation.
func withClass(node *Class) classOption {
	return func(m *ClassMutation) {
		m.oldValue = func(context.Context) (*Class, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Class entities.
func (m *ClassMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClassMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClassMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Class.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCid sets the "cid" field.
func (m *ClassMutation) SetCid(u uint16) {
	m.college = &u
}

// Cid returns the value of the "cid" field in the mutation.
func (m *ClassMutation) Cid() (r uint16, exists bool) {
	v := m.college
	if v == nil {
		return
	}
	return *v, true
}

// OldCid returns the old "cid" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldCid(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCid: %w", err)
	}
	return oldValue.Cid, nil
}

// ResetCid resets all changes to the "cid" field.
func (m *ClassMutation) ResetCid() {
	m.college = nil
}

// SetName sets the "name" field.
func (m *ClassMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ClassMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ClassMutation) ResetName() {
	m.name = nil
}

// SetIsDisabled sets the "is_disabled" field.
func (m *ClassMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *ClassMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *ClassMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *ClassMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *ClassMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *ClassMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *ClassMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *ClassMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldDeletedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *ClassMutation) ResetDeletedTime() {
	m.deleted_time = nil
}

// SetModifiedTime sets the "modified_time" field.
func (m *ClassMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *ClassMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldModifiedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *ClassMutation) ResetModifiedTime() {
	m.modified_time = nil
}

// SetCollegeID sets the "college" edge to the College entity by id.
func (m *ClassMutation) SetCollegeID(id uint16) {
	m.college = &id
}

// ClearCollege clears the "college" edge to the College entity.
func (m *ClassMutation) ClearCollege() {
	m.clearedcollege = true
}

// CollegeCleared reports if the "college" edge to the College entity was cleared.
func (m *ClassMutation) CollegeCleared() bool {
	return m.clearedcollege
}

// CollegeID returns the "college" edge ID in the mutation.
func (m *ClassMutation) CollegeID() (id uint16, exists bool) {
	if m.college != nil {
		return *m.college, true
	}
	return
}

// CollegeIDs returns the "college" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CollegeID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) CollegeIDs() (ids []uint16) {
	if id := m.college; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCollege resets all changes to the "college" edge.
func (m *ClassMutation) ResetCollege() {
	m.college = nil
	m.clearedcollege = false
}

// AddStudentIDs adds the "students" edge to the Student entity by ids.
func (m *ClassMutation) AddStudentIDs(ids ...uint32) {
	if m.students == nil {
		m.students = make(map[uint32]struct{})
	}
	for i := range ids {
		m.students[ids[i]] = struct{}{}
	}
}

// ClearStudents clears the "students" edge to the Student entity.
func (m *ClassMutation) ClearStudents() {
	m.clearedstudents = true
}

// StudentsCleared reports if the "students" edge to the Student entity was cleared.
func (m *ClassMutation) StudentsCleared() bool {
	return m.clearedstudents
}

// RemoveStudentIDs removes the "students" edge to the Student entity by IDs.
func (m *ClassMutation) RemoveStudentIDs(ids ...uint32) {
	if m.removedstudents == nil {
		m.removedstudents = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.students, ids[i])
		m.removedstudents[ids[i]] = struct{}{}
	}
}

// RemovedStudents returns the removed IDs of the "students" edge to the Student entity.
func (m *ClassMutation) RemovedStudentsIDs() (ids []uint32) {
	for id := range m.removedstudents {
		ids = append(ids, id)
	}
	return
}

// StudentsIDs returns the "students" edge IDs in the mutation.
func (m *ClassMutation) StudentsIDs() (ids []uint32) {
	for id := range m.students {
		ids = append(ids, id)
	}
	return
}

// ResetStudents resets all changes to the "students" edge.
func (m *ClassMutation) ResetStudents() {
	m.students = nil
	m.clearedstudents = false
	m.removedstudents = nil
}

// Where appends a list predicates to the ClassMutation builder.
func (m *ClassMutation) Where(ps ...predicate.Class) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClassMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClassMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Class, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClassMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClassMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Class).
func (m *ClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClassMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.college != nil {
		fields = append(fields, class.FieldCid)
	}
	if m.name != nil {
		fields = append(fields, class.FieldName)
	}
	if m.is_disabled != nil {
		fields = append(fields, class.FieldIsDisabled)
	}
	if m.created_time != nil {
		fields = append(fields, class.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, class.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, class.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case class.FieldCid:
		return m.Cid()
	case class.FieldName:
		return m.Name()
	case class.FieldIsDisabled:
		return m.IsDisabled()
	case class.FieldCreatedTime:
		return m.CreatedTime()
	case class.FieldDeletedTime:
		return m.DeletedTime()
	case class.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case class.FieldCid:
		return m.OldCid(ctx)
	case class.FieldName:
		return m.OldName(ctx)
	case class.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case class.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case class.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case class.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Class field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case class.FieldCid:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCid(v)
		return nil
	case class.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case class.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case class.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case class.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case class.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClassMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClassMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Class numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClassMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Class nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClassMutation) ResetField(name string) error {
	switch name {
	case class.FieldCid:
		m.ResetCid()
		return nil
	case class.FieldName:
		m.ResetName()
		return nil
	case class.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case class.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case class.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case class.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.college != nil {
		edges = append(edges, class.EdgeCollege)
	}
	if m.students != nil {
		edges = append(edges, class.EdgeStudents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case class.EdgeCollege:
		if id := m.college; id != nil {
			return []ent.Value{*id}
		}
	case class.EdgeStudents:
		ids := make([]ent.Value, 0, len(m.students))
		for id := range m.students {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedstudents != nil {
		edges = append(edges, class.EdgeStudents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClassMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case class.EdgeStudents:
		ids := make([]ent.Value, 0, len(m.removedstudents))
		for id := range m.removedstudents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcollege {
		edges = append(edges, class.EdgeCollege)
	}
	if m.clearedstudents {
		edges = append(edges, class.EdgeStudents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClassMutation) EdgeCleared(name string) bool {
	switch name {
	case class.EdgeCollege:
		return m.clearedcollege
	case class.EdgeStudents:
		return m.clearedstudents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClassMutation) ClearEdge(name string) error {
	switch name {
	case class.EdgeCollege:
		m.ClearCollege()
		return nil
	}
	return fmt.Errorf("unknown Class unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClassMutation) ResetEdge(name string) error {
	switch name {
	case class.EdgeCollege:
		m.ResetCollege()
		return nil
	case class.EdgeStudents:
		m.ResetStudents()
		return nil
	}
	return fmt.Errorf("unknown Class edge %s", name)
}

// CollegeMutation represents an operation that mutates the College nodes in the graph.
type CollegeMutation struct {
	config
	op             Op
	typ            string
	id             *uint16
	name           *string
	is_disabled    *bool
	created_time   *time.Time
	deleted_time   *time.Time
	modified_time  *time.Time
	clearedFields  map[string]struct{}
	school         *uint16
	clearedschool  bool
	classes        map[uint32]struct{}
	removedclasses map[uint32]struct{}
	clearedclasses bool
	done           bool
	oldValue       func(context.Context) (*College, error)
	predicates     []predicate.College
}

var _ ent.Mutation = (*CollegeMutation)(nil)

// collegeOption allows management of the mutation configuration using functional options.
type collegeOption func(*CollegeMutation)

// newCollegeMutation creates new mutation for the College entity.
func newCollegeMutation(c config, op Op, opts ...collegeOption) *CollegeMutation {
	m := &CollegeMutation{
		config:        c,
		op:            op,
		typ:           TypeCollege,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCollegeID sets the ID field of the mutation.
func withCollegeID(id uint16) collegeOption {
	return func(m *CollegeMutation) {
		var (
			err   error
			once  sync.Once
			value *College
		)
		m.oldValue = func(ctx context.Context) (*College, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().College.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCollege sets the old College of the mutation.
func withCollege(node *College) collegeOption {
	return func(m *CollegeMutation) {
		m.oldValue = func(context.Context) (*College, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CollegeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CollegeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of College entities.
func (m *CollegeMutation) SetID(id uint16) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CollegeMutation) ID() (id uint16, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CollegeMutation) IDs(ctx context.Context) ([]uint16, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint16{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().College.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSid sets the "sid" field.
func (m *CollegeMutation) SetSid(u uint16) {
	m.school = &u
}

// Sid returns the value of the "sid" field in the mutation.
func (m *CollegeMutation) Sid() (r uint16, exists bool) {
	v := m.school
	if v == nil {
		return
	}
	return *v, true
}

// OldSid returns the old "sid" field's value of the College entity.
// If the College object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollegeMutation) OldSid(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSid: %w", err)
	}
	return oldValue.Sid, nil
}

// ResetSid resets all changes to the "sid" field.
func (m *CollegeMutation) ResetSid() {
	m.school = nil
}

// SetName sets the "name" field.
func (m *CollegeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CollegeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the College entity.
// If the College object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollegeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CollegeMutation) ResetName() {
	m.name = nil
}

// SetIsDisabled sets the "is_disabled" field.
func (m *CollegeMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *CollegeMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the College entity.
// If the College object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollegeMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *CollegeMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *CollegeMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *CollegeMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the College entity.
// If the College object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollegeMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *CollegeMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *CollegeMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *CollegeMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the College entity.
// If the College object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollegeMutation) OldDeletedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *CollegeMutation) ResetDeletedTime() {
	m.deleted_time = nil
}

// SetModifiedTime sets the "modified_time" field.
func (m *CollegeMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *CollegeMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the College entity.
// If the College object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollegeMutation) OldModifiedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *CollegeMutation) ResetModifiedTime() {
	m.modified_time = nil
}

// SetSchoolID sets the "school" edge to the School entity by id.
func (m *CollegeMutation) SetSchoolID(id uint16) {
	m.school = &id
}

// ClearSchool clears the "school" edge to the School entity.
func (m *CollegeMutation) ClearSchool() {
	m.clearedschool = true
}

// SchoolCleared reports if the "school" edge to the School entity was cleared.
func (m *CollegeMutation) SchoolCleared() bool {
	return m.clearedschool
}

// SchoolID returns the "school" edge ID in the mutation.
func (m *CollegeMutation) SchoolID() (id uint16, exists bool) {
	if m.school != nil {
		return *m.school, true
	}
	return
}

// SchoolIDs returns the "school" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SchoolID instead. It exists only for internal usage by the builders.
func (m *CollegeMutation) SchoolIDs() (ids []uint16) {
	if id := m.school; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchool resets all changes to the "school" edge.
func (m *CollegeMutation) ResetSchool() {
	m.school = nil
	m.clearedschool = false
}

// AddClassIDs adds the "classes" edge to the Class entity by ids.
func (m *CollegeMutation) AddClassIDs(ids ...uint32) {
	if m.classes == nil {
		m.classes = make(map[uint32]struct{})
	}
	for i := range ids {
		m.classes[ids[i]] = struct{}{}
	}
}

// ClearClasses clears the "classes" edge to the Class entity.
func (m *CollegeMutation) ClearClasses() {
	m.clearedclasses = true
}

// ClassesCleared reports if the "classes" edge to the Class entity was cleared.
func (m *CollegeMutation) ClassesCleared() bool {
	return m.clearedclasses
}

// RemoveClassIDs removes the "classes" edge to the Class entity by IDs.
func (m *CollegeMutation) RemoveClassIDs(ids ...uint32) {
	if m.removedclasses == nil {
		m.removedclasses = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.classes, ids[i])
		m.removedclasses[ids[i]] = struct{}{}
	}
}

// RemovedClasses returns the removed IDs of the "classes" edge to the Class entity.
func (m *CollegeMutation) RemovedClassesIDs() (ids []uint32) {
	for id := range m.removedclasses {
		ids = append(ids, id)
	}
	return
}

// ClassesIDs returns the "classes" edge IDs in the mutation.
func (m *CollegeMutation) ClassesIDs() (ids []uint32) {
	for id := range m.classes {
		ids = append(ids, id)
	}
	return
}

// ResetClasses resets all changes to the "classes" edge.
func (m *CollegeMutation) ResetClasses() {
	m.classes = nil
	m.clearedclasses = false
	m.removedclasses = nil
}

// Where appends a list predicates to the CollegeMutation builder.
func (m *CollegeMutation) Where(ps ...predicate.College) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CollegeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CollegeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.College, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CollegeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CollegeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (College).
func (m *CollegeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CollegeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.school != nil {
		fields = append(fields, college.FieldSid)
	}
	if m.name != nil {
		fields = append(fields, college.FieldName)
	}
	if m.is_disabled != nil {
		fields = append(fields, college.FieldIsDisabled)
	}
	if m.created_time != nil {
		fields = append(fields, college.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, college.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, college.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CollegeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case college.FieldSid:
		return m.Sid()
	case college.FieldName:
		return m.Name()
	case college.FieldIsDisabled:
		return m.IsDisabled()
	case college.FieldCreatedTime:
		return m.CreatedTime()
	case college.FieldDeletedTime:
		return m.DeletedTime()
	case college.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CollegeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case college.FieldSid:
		return m.OldSid(ctx)
	case college.FieldName:
		return m.OldName(ctx)
	case college.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case college.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case college.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case college.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown College field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollegeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case college.FieldSid:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSid(v)
		return nil
	case college.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case college.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case college.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case college.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case college.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown College field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CollegeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CollegeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollegeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown College numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CollegeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CollegeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CollegeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown College nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CollegeMutation) ResetField(name string) error {
	switch name {
	case college.FieldSid:
		m.ResetSid()
		return nil
	case college.FieldName:
		m.ResetName()
		return nil
	case college.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case college.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case college.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case college.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown College field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CollegeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.school != nil {
		edges = append(edges, college.EdgeSchool)
	}
	if m.classes != nil {
		edges = append(edges, college.EdgeClasses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CollegeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case college.EdgeSchool:
		if id := m.school; id != nil {
			return []ent.Value{*id}
		}
	case college.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.classes))
		for id := range m.classes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CollegeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedclasses != nil {
		edges = append(edges, college.EdgeClasses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CollegeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case college.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.removedclasses))
		for id := range m.removedclasses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CollegeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedschool {
		edges = append(edges, college.EdgeSchool)
	}
	if m.clearedclasses {
		edges = append(edges, college.EdgeClasses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CollegeMutation) EdgeCleared(name string) bool {
	switch name {
	case college.EdgeSchool:
		return m.clearedschool
	case college.EdgeClasses:
		return m.clearedclasses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CollegeMutation) ClearEdge(name string) error {
	switch name {
	case college.EdgeSchool:
		m.ClearSchool()
		return nil
	}
	return fmt.Errorf("unknown College unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CollegeMutation) ResetEdge(name string) error {
	switch name {
	case college.EdgeSchool:
		m.ResetSchool()
		return nil
	case college.EdgeClasses:
		m.ResetClasses()
		return nil
	}
	return fmt.Errorf("unknown College edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	name           *string
	_path          *string
	size           *int64
	addsize        *int64
	is_disabled    *bool
	created_time   *time.Time
	deleted_time   *time.Time
	modified_time  *time.Time
	clearedFields  map[string]struct{}
	creator        *uint32
	clearedcreator bool
	sample         *uint8
	clearedsample  bool
	done           bool
	oldValue       func(context.Context) (*File, error)
	predicates     []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id uint32) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of File entities.
func (m *FileMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *FileMutation) SetUID(u uint32) {
	m.creator = &u
}

// UID returns the value of the "uid" field in the mutation.
func (m *FileMutation) UID() (r uint32, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *FileMutation) ResetUID() {
	m.creator = nil
}

// SetName sets the "name" field.
func (m *FileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FileMutation) ResetName() {
	m.name = nil
}

// SetPath sets the "path" field.
func (m *FileMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *FileMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *FileMutation) ResetPath() {
	m._path = nil
}

// SetSize sets the "size" field.
func (m *FileMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FileMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *FileMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FileMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of the "size" field.
func (m *FileMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[file.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *FileMutation) SizeCleared() bool {
	_, ok := m.clearedFields[file.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *FileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, file.FieldSize)
}

// SetIsDisabled sets the "is_disabled" field.
func (m *FileMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *FileMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *FileMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *FileMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *FileMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *FileMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *FileMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *FileMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDeletedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ClearDeletedTime clears the value of the "deleted_time" field.
func (m *FileMutation) ClearDeletedTime() {
	m.deleted_time = nil
	m.clearedFields[file.FieldDeletedTime] = struct{}{}
}

// DeletedTimeCleared returns if the "deleted_time" field was cleared in this mutation.
func (m *FileMutation) DeletedTimeCleared() bool {
	_, ok := m.clearedFields[file.FieldDeletedTime]
	return ok
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *FileMutation) ResetDeletedTime() {
	m.deleted_time = nil
	delete(m.clearedFields, file.FieldDeletedTime)
}

// SetModifiedTime sets the "modified_time" field.
func (m *FileMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *FileMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldModifiedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ClearModifiedTime clears the value of the "modified_time" field.
func (m *FileMutation) ClearModifiedTime() {
	m.modified_time = nil
	m.clearedFields[file.FieldModifiedTime] = struct{}{}
}

// ModifiedTimeCleared returns if the "modified_time" field was cleared in this mutation.
func (m *FileMutation) ModifiedTimeCleared() bool {
	_, ok := m.clearedFields[file.FieldModifiedTime]
	return ok
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *FileMutation) ResetModifiedTime() {
	m.modified_time = nil
	delete(m.clearedFields, file.FieldModifiedTime)
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *FileMutation) SetCreatorID(id uint32) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *FileMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *FileMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *FileMutation) CreatorID() (id uint32, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *FileMutation) CreatorIDs() (ids []uint32) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *FileMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetSampleID sets the "sample" edge to the SampleFile entity by id.
func (m *FileMutation) SetSampleID(id uint8) {
	m.sample = &id
}

// ClearSample clears the "sample" edge to the SampleFile entity.
func (m *FileMutation) ClearSample() {
	m.clearedsample = true
}

// SampleCleared reports if the "sample" edge to the SampleFile entity was cleared.
func (m *FileMutation) SampleCleared() bool {
	return m.clearedsample
}

// SampleID returns the "sample" edge ID in the mutation.
func (m *FileMutation) SampleID() (id uint8, exists bool) {
	if m.sample != nil {
		return *m.sample, true
	}
	return
}

// SampleIDs returns the "sample" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SampleID instead. It exists only for internal usage by the builders.
func (m *FileMutation) SampleIDs() (ids []uint8) {
	if id := m.sample; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSample resets all changes to the "sample" edge.
func (m *FileMutation) ResetSample() {
	m.sample = nil
	m.clearedsample = false
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.creator != nil {
		fields = append(fields, file.FieldUID)
	}
	if m.name != nil {
		fields = append(fields, file.FieldName)
	}
	if m._path != nil {
		fields = append(fields, file.FieldPath)
	}
	if m.size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m.is_disabled != nil {
		fields = append(fields, file.FieldIsDisabled)
	}
	if m.created_time != nil {
		fields = append(fields, file.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, file.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, file.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldUID:
		return m.UID()
	case file.FieldName:
		return m.Name()
	case file.FieldPath:
		return m.Path()
	case file.FieldSize:
		return m.Size()
	case file.FieldIsDisabled:
		return m.IsDisabled()
	case file.FieldCreatedTime:
		return m.CreatedTime()
	case file.FieldDeletedTime:
		return m.DeletedTime()
	case file.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldUID:
		return m.OldUID(ctx)
	case file.FieldName:
		return m.OldName(ctx)
	case file.FieldPath:
		return m.OldPath(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case file.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case file.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case file.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldUID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case file.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case file.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case file.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case file.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case file.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case file.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, file.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldSize) {
		fields = append(fields, file.FieldSize)
	}
	if m.FieldCleared(file.FieldDeletedTime) {
		fields = append(fields, file.FieldDeletedTime)
	}
	if m.FieldCleared(file.FieldModifiedTime) {
		fields = append(fields, file.FieldModifiedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldSize:
		m.ClearSize()
		return nil
	case file.FieldDeletedTime:
		m.ClearDeletedTime()
		return nil
	case file.FieldModifiedTime:
		m.ClearModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldUID:
		m.ResetUID()
		return nil
	case file.FieldName:
		m.ResetName()
		return nil
	case file.FieldPath:
		m.ResetPath()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case file.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case file.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case file.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.creator != nil {
		edges = append(edges, file.EdgeCreator)
	}
	if m.sample != nil {
		edges = append(edges, file.EdgeSample)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeSample:
		if id := m.sample; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcreator {
		edges = append(edges, file.EdgeCreator)
	}
	if m.clearedsample {
		edges = append(edges, file.EdgeSample)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeCreator:
		return m.clearedcreator
	case file.EdgeSample:
		return m.clearedsample
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeCreator:
		m.ClearCreator()
		return nil
	case file.EdgeSample:
		m.ClearSample()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeCreator:
		m.ResetCreator()
		return nil
	case file.EdgeSample:
		m.ResetSample()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// MenuMutation represents an operation that mutates the Menu nodes in the graph.
type MenuMutation struct {
	config
	op              Op
	typ             string
	id              *uint8
	name            *string
	json_menu       *[]*entity.Menu
	appendjson_menu []*entity.Menu
	created_time    *time.Time
	deleted_time    *time.Time
	modified_time   *time.Time
	clearedFields   map[string]struct{}
	role            *uint8
	clearedrole     bool
	done            bool
	oldValue        func(context.Context) (*Menu, error)
	predicates      []predicate.Menu
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows management of the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for the Menu entity.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the ID field of the mutation.
func withMenuID(id uint8) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Menu entities.
func (m *MenuMutation) SetID(id uint8) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuMutation) ID() (id uint8, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuMutation) IDs(ctx context.Context) ([]uint8, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint8{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Menu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MenuMutation) ResetName() {
	m.name = nil
}

// SetJSONMenu sets the "json_menu" field.
func (m *MenuMutation) SetJSONMenu(e []*entity.Menu) {
	m.json_menu = &e
	m.appendjson_menu = nil
}

// JSONMenu returns the value of the "json_menu" field in the mutation.
func (m *MenuMutation) JSONMenu() (r []*entity.Menu, exists bool) {
	v := m.json_menu
	if v == nil {
		return
	}
	return *v, true
}

// OldJSONMenu returns the old "json_menu" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldJSONMenu(ctx context.Context) (v []*entity.Menu, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJSONMenu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJSONMenu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJSONMenu: %w", err)
	}
	return oldValue.JSONMenu, nil
}

// AppendJSONMenu adds e to the "json_menu" field.
func (m *MenuMutation) AppendJSONMenu(e []*entity.Menu) {
	m.appendjson_menu = append(m.appendjson_menu, e...)
}

// AppendedJSONMenu returns the list of values that were appended to the "json_menu" field in this mutation.
func (m *MenuMutation) AppendedJSONMenu() ([]*entity.Menu, bool) {
	if len(m.appendjson_menu) == 0 {
		return nil, false
	}
	return m.appendjson_menu, true
}

// ClearJSONMenu clears the value of the "json_menu" field.
func (m *MenuMutation) ClearJSONMenu() {
	m.json_menu = nil
	m.appendjson_menu = nil
	m.clearedFields[menu.FieldJSONMenu] = struct{}{}
}

// JSONMenuCleared returns if the "json_menu" field was cleared in this mutation.
func (m *MenuMutation) JSONMenuCleared() bool {
	_, ok := m.clearedFields[menu.FieldJSONMenu]
	return ok
}

// ResetJSONMenu resets all changes to the "json_menu" field.
func (m *MenuMutation) ResetJSONMenu() {
	m.json_menu = nil
	m.appendjson_menu = nil
	delete(m.clearedFields, menu.FieldJSONMenu)
}

// SetRid sets the "rid" field.
func (m *MenuMutation) SetRid(u uint8) {
	m.role = &u
}

// Rid returns the value of the "rid" field in the mutation.
func (m *MenuMutation) Rid() (r uint8, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRid returns the old "rid" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldRid(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRid: %w", err)
	}
	return oldValue.Rid, nil
}

// ResetRid resets all changes to the "rid" field.
func (m *MenuMutation) ResetRid() {
	m.role = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *MenuMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *MenuMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *MenuMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *MenuMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *MenuMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDeletedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *MenuMutation) ResetDeletedTime() {
	m.deleted_time = nil
}

// SetModifiedTime sets the "modified_time" field.
func (m *MenuMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *MenuMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldModifiedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *MenuMutation) ResetModifiedTime() {
	m.modified_time = nil
}

// SetRoleID sets the "role" edge to the Role entity by id.
func (m *MenuMutation) SetRoleID(id uint8) {
	m.role = &id
}

// ClearRole clears the "role" edge to the Role entity.
func (m *MenuMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *MenuMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleID returns the "role" edge ID in the mutation.
func (m *MenuMutation) RoleID() (id uint8, exists bool) {
	if m.role != nil {
		return *m.role, true
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *MenuMutation) RoleIDs() (ids []uint8) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *MenuMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the MenuMutation builder.
func (m *MenuMutation) Where(ps ...predicate.Menu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Menu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, menu.FieldName)
	}
	if m.json_menu != nil {
		fields = append(fields, menu.FieldJSONMenu)
	}
	if m.role != nil {
		fields = append(fields, menu.FieldRid)
	}
	if m.created_time != nil {
		fields = append(fields, menu.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, menu.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, menu.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldName:
		return m.Name()
	case menu.FieldJSONMenu:
		return m.JSONMenu()
	case menu.FieldRid:
		return m.Rid()
	case menu.FieldCreatedTime:
		return m.CreatedTime()
	case menu.FieldDeletedTime:
		return m.DeletedTime()
	case menu.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menu.FieldName:
		return m.OldName(ctx)
	case menu.FieldJSONMenu:
		return m.OldJSONMenu(ctx)
	case menu.FieldRid:
		return m.OldRid(ctx)
	case menu.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case menu.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case menu.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menu.FieldJSONMenu:
		v, ok := value.([]*entity.Menu)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJSONMenu(v)
		return nil
	case menu.FieldRid:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRid(v)
		return nil
	case menu.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case menu.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case menu.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menu.FieldJSONMenu) {
		fields = append(fields, menu.FieldJSONMenu)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	switch name {
	case menu.FieldJSONMenu:
		m.ClearJSONMenu()
		return nil
	}
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	switch name {
	case menu.FieldName:
		m.ResetName()
		return nil
	case menu.FieldJSONMenu:
		m.ResetJSONMenu()
		return nil
	case menu.FieldRid:
		m.ResetRid()
		return nil
	case menu.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case menu.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case menu.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.role != nil {
		edges = append(edges, menu.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrole {
		edges = append(edges, menu.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	switch name {
	case menu.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	switch name {
	case menu.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	switch name {
	case menu.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown Menu edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op            Op
	typ           string
	id            *uint16
	action        *string
	description   *string
	is_disabled   *bool
	created_time  *time.Time
	deleted_time  *time.Time
	modified_time *time.Time
	clearedFields map[string]struct{}
	roles         map[uint8]struct{}
	removedroles  map[uint8]struct{}
	clearedroles  bool
	done          bool
	oldValue      func(context.Context) (*Permission, error)
	predicates    []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id uint16) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Permission entities.
func (m *PermissionMutation) SetID(id uint16) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id uint16, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]uint16, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint16{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAction sets the "action" field.
func (m *PermissionMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *PermissionMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *PermissionMutation) ResetAction() {
	m.action = nil
}

// SetDescription sets the "description" field.
func (m *PermissionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PermissionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PermissionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[permission.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PermissionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[permission.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PermissionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, permission.FieldDescription)
}

// SetIsDisabled sets the "is_disabled" field.
func (m *PermissionMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *PermissionMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *PermissionMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *PermissionMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *PermissionMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *PermissionMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *PermissionMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *PermissionMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDeletedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *PermissionMutation) ResetDeletedTime() {
	m.deleted_time = nil
}

// SetModifiedTime sets the "modified_time" field.
func (m *PermissionMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *PermissionMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldModifiedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *PermissionMutation) ResetModifiedTime() {
	m.modified_time = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *PermissionMutation) AddRoleIDs(ids ...uint8) {
	if m.roles == nil {
		m.roles = make(map[uint8]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *PermissionMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *PermissionMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *PermissionMutation) RemoveRoleIDs(ids ...uint8) {
	if m.removedroles == nil {
		m.removedroles = make(map[uint8]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *PermissionMutation) RemovedRolesIDs() (ids []uint8) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *PermissionMutation) RolesIDs() (ids []uint8) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *PermissionMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Permission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.action != nil {
		fields = append(fields, permission.FieldAction)
	}
	if m.description != nil {
		fields = append(fields, permission.FieldDescription)
	}
	if m.is_disabled != nil {
		fields = append(fields, permission.FieldIsDisabled)
	}
	if m.created_time != nil {
		fields = append(fields, permission.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, permission.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, permission.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldAction:
		return m.Action()
	case permission.FieldDescription:
		return m.Description()
	case permission.FieldIsDisabled:
		return m.IsDisabled()
	case permission.FieldCreatedTime:
		return m.CreatedTime()
	case permission.FieldDeletedTime:
		return m.DeletedTime()
	case permission.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldAction:
		return m.OldAction(ctx)
	case permission.FieldDescription:
		return m.OldDescription(ctx)
	case permission.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case permission.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case permission.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case permission.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case permission.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case permission.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case permission.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case permission.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case permission.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permission.FieldDescription) {
		fields = append(fields, permission.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	switch name {
	case permission.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldAction:
		m.ResetAction()
		return nil
	case permission.FieldDescription:
		m.ResetDescription()
		return nil
	case permission.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case permission.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case permission.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case permission.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roles != nil {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroles != nil {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedroles {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint8
	name               *string
	description        *string
	is_disabled        *bool
	created_time       *time.Time
	modified_time      *time.Time
	deleted_time       *time.Time
	clearedFields      map[string]struct{}
	permissions        map[uint16]struct{}
	removedpermissions map[uint16]struct{}
	clearedpermissions bool
	menu               map[uint8]struct{}
	removedmenu        map[uint8]struct{}
	clearedmenu        bool
	users              map[uint32]struct{}
	removedusers       map[uint32]struct{}
	clearedusers       bool
	done               bool
	oldValue           func(context.Context) (*Role, error)
	predicates         []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id uint8) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id uint8) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id uint8, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]uint8, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint8{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[role.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[role.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, role.FieldDescription)
}

// SetIsDisabled sets the "is_disabled" field.
func (m *RoleMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *RoleMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *RoleMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *RoleMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *RoleMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *RoleMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetModifiedTime sets the "modified_time" field.
func (m *RoleMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *RoleMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldModifiedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *RoleMutation) ResetModifiedTime() {
	m.modified_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *RoleMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *RoleMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDeletedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *RoleMutation) ResetDeletedTime() {
	m.deleted_time = nil
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *RoleMutation) AddPermissionIDs(ids ...uint16) {
	if m.permissions == nil {
		m.permissions = make(map[uint16]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *RoleMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *RoleMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *RoleMutation) RemovePermissionIDs(ids ...uint16) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[uint16]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *RoleMutation) RemovedPermissionsIDs() (ids []uint16) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *RoleMutation) PermissionsIDs() (ids []uint16) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *RoleMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddMenuIDs adds the "menu" edge to the Menu entity by ids.
func (m *RoleMutation) AddMenuIDs(ids ...uint8) {
	if m.menu == nil {
		m.menu = make(map[uint8]struct{})
	}
	for i := range ids {
		m.menu[ids[i]] = struct{}{}
	}
}

// ClearMenu clears the "menu" edge to the Menu entity.
func (m *RoleMutation) ClearMenu() {
	m.clearedmenu = true
}

// MenuCleared reports if the "menu" edge to the Menu entity was cleared.
func (m *RoleMutation) MenuCleared() bool {
	return m.clearedmenu
}

// RemoveMenuIDs removes the "menu" edge to the Menu entity by IDs.
func (m *RoleMutation) RemoveMenuIDs(ids ...uint8) {
	if m.removedmenu == nil {
		m.removedmenu = make(map[uint8]struct{})
	}
	for i := range ids {
		delete(m.menu, ids[i])
		m.removedmenu[ids[i]] = struct{}{}
	}
}

// RemovedMenu returns the removed IDs of the "menu" edge to the Menu entity.
func (m *RoleMutation) RemovedMenuIDs() (ids []uint8) {
	for id := range m.removedmenu {
		ids = append(ids, id)
	}
	return
}

// MenuIDs returns the "menu" edge IDs in the mutation.
func (m *RoleMutation) MenuIDs() (ids []uint8) {
	for id := range m.menu {
		ids = append(ids, id)
	}
	return
}

// ResetMenu resets all changes to the "menu" edge.
func (m *RoleMutation) ResetMenu() {
	m.menu = nil
	m.clearedmenu = false
	m.removedmenu = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...uint32) {
	if m.users == nil {
		m.users = make(map[uint32]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...uint32) {
	if m.removedusers == nil {
		m.removedusers = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []uint32) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []uint32) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	if m.is_disabled != nil {
		fields = append(fields, role.FieldIsDisabled)
	}
	if m.created_time != nil {
		fields = append(fields, role.FieldCreatedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, role.FieldModifiedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, role.FieldDeletedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldName:
		return m.Name()
	case role.FieldDescription:
		return m.Description()
	case role.FieldIsDisabled:
		return m.IsDisabled()
	case role.FieldCreatedTime:
		return m.CreatedTime()
	case role.FieldModifiedTime:
		return m.ModifiedTime()
	case role.FieldDeletedTime:
		return m.DeletedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	case role.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case role.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case role.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	case role.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case role.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case role.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case role.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	case role.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldDescription) {
		fields = append(fields, role.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	case role.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case role.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case role.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	case role.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.permissions != nil {
		edges = append(edges, role.EdgePermissions)
	}
	if m.menu != nil {
		edges = append(edges, role.EdgeMenu)
	}
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeMenu:
		ids := make([]ent.Value, 0, len(m.menu))
		for id := range m.menu {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedpermissions != nil {
		edges = append(edges, role.EdgePermissions)
	}
	if m.removedmenu != nil {
		edges = append(edges, role.EdgeMenu)
	}
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeMenu:
		ids := make([]ent.Value, 0, len(m.removedmenu))
		for id := range m.removedmenu {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpermissions {
		edges = append(edges, role.EdgePermissions)
	}
	if m.clearedmenu {
		edges = append(edges, role.EdgeMenu)
	}
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgePermissions:
		return m.clearedpermissions
	case role.EdgeMenu:
		return m.clearedmenu
	case role.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgePermissions:
		m.ResetPermissions()
		return nil
	case role.EdgeMenu:
		m.ResetMenu()
		return nil
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// RolePermissionMutation represents an operation that mutates the RolePermission nodes in the graph.
type RolePermissionMutation struct {
	config
	op                Op
	typ               string
	created_time      *time.Time
	clearedFields     map[string]struct{}
	role              *uint8
	clearedrole       bool
	permission        *uint16
	clearedpermission bool
	done              bool
	oldValue          func(context.Context) (*RolePermission, error)
	predicates        []predicate.RolePermission
}

var _ ent.Mutation = (*RolePermissionMutation)(nil)

// rolepermissionOption allows management of the mutation configuration using functional options.
type rolepermissionOption func(*RolePermissionMutation)

// newRolePermissionMutation creates new mutation for the RolePermission entity.
func newRolePermissionMutation(c config, op Op, opts ...rolepermissionOption) *RolePermissionMutation {
	m := &RolePermissionMutation{
		config:        c,
		op:            op,
		typ:           TypeRolePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RolePermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RolePermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetRid sets the "rid" field.
func (m *RolePermissionMutation) SetRid(u uint8) {
	m.role = &u
}

// Rid returns the value of the "rid" field in the mutation.
func (m *RolePermissionMutation) Rid() (r uint8, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// ResetRid resets all changes to the "rid" field.
func (m *RolePermissionMutation) ResetRid() {
	m.role = nil
}

// SetPid sets the "pid" field.
func (m *RolePermissionMutation) SetPid(u uint16) {
	m.permission = &u
}

// Pid returns the value of the "pid" field in the mutation.
func (m *RolePermissionMutation) Pid() (r uint16, exists bool) {
	v := m.permission
	if v == nil {
		return
	}
	return *v, true
}

// ResetPid resets all changes to the "pid" field.
func (m *RolePermissionMutation) ResetPid() {
	m.permission = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *RolePermissionMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *RolePermissionMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *RolePermissionMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetRoleID sets the "role" edge to the Role entity by id.
func (m *RolePermissionMutation) SetRoleID(id uint8) {
	m.role = &id
}

// ClearRole clears the "role" edge to the Role entity.
func (m *RolePermissionMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *RolePermissionMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleID returns the "role" edge ID in the mutation.
func (m *RolePermissionMutation) RoleID() (id uint8, exists bool) {
	if m.role != nil {
		return *m.role, true
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *RolePermissionMutation) RoleIDs() (ids []uint8) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *RolePermissionMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// SetPermissionID sets the "permission" edge to the Permission entity by id.
func (m *RolePermissionMutation) SetPermissionID(id uint16) {
	m.permission = &id
}

// ClearPermission clears the "permission" edge to the Permission entity.
func (m *RolePermissionMutation) ClearPermission() {
	m.clearedpermission = true
}

// PermissionCleared reports if the "permission" edge to the Permission entity was cleared.
func (m *RolePermissionMutation) PermissionCleared() bool {
	return m.clearedpermission
}

// PermissionID returns the "permission" edge ID in the mutation.
func (m *RolePermissionMutation) PermissionID() (id uint16, exists bool) {
	if m.permission != nil {
		return *m.permission, true
	}
	return
}

// PermissionIDs returns the "permission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PermissionID instead. It exists only for internal usage by the builders.
func (m *RolePermissionMutation) PermissionIDs() (ids []uint16) {
	if id := m.permission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPermission resets all changes to the "permission" edge.
func (m *RolePermissionMutation) ResetPermission() {
	m.permission = nil
	m.clearedpermission = false
}

// Where appends a list predicates to the RolePermissionMutation builder.
func (m *RolePermissionMutation) Where(ps ...predicate.RolePermission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RolePermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RolePermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RolePermission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RolePermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RolePermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RolePermission).
func (m *RolePermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RolePermissionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.role != nil {
		fields = append(fields, rolepermission.FieldRid)
	}
	if m.permission != nil {
		fields = append(fields, rolepermission.FieldPid)
	}
	if m.created_time != nil {
		fields = append(fields, rolepermission.FieldCreatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RolePermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rolepermission.FieldRid:
		return m.Rid()
	case rolepermission.FieldPid:
		return m.Pid()
	case rolepermission.FieldCreatedTime:
		return m.CreatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RolePermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema RolePermission does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RolePermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rolepermission.FieldRid:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRid(v)
		return nil
	case rolepermission.FieldPid:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPid(v)
		return nil
	case rolepermission.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown RolePermission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RolePermissionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RolePermissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RolePermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RolePermission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RolePermissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RolePermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RolePermissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RolePermission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RolePermissionMutation) ResetField(name string) error {
	switch name {
	case rolepermission.FieldRid:
		m.ResetRid()
		return nil
	case rolepermission.FieldPid:
		m.ResetPid()
		return nil
	case rolepermission.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown RolePermission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RolePermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.role != nil {
		edges = append(edges, rolepermission.EdgeRole)
	}
	if m.permission != nil {
		edges = append(edges, rolepermission.EdgePermission)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RolePermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rolepermission.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	case rolepermission.EdgePermission:
		if id := m.permission; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RolePermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RolePermissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RolePermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrole {
		edges = append(edges, rolepermission.EdgeRole)
	}
	if m.clearedpermission {
		edges = append(edges, rolepermission.EdgePermission)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RolePermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case rolepermission.EdgeRole:
		return m.clearedrole
	case rolepermission.EdgePermission:
		return m.clearedpermission
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RolePermissionMutation) ClearEdge(name string) error {
	switch name {
	case rolepermission.EdgeRole:
		m.ClearRole()
		return nil
	case rolepermission.EdgePermission:
		m.ClearPermission()
		return nil
	}
	return fmt.Errorf("unknown RolePermission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RolePermissionMutation) ResetEdge(name string) error {
	switch name {
	case rolepermission.EdgeRole:
		m.ResetRole()
		return nil
	case rolepermission.EdgePermission:
		m.ResetPermission()
		return nil
	}
	return fmt.Errorf("unknown RolePermission edge %s", name)
}

// SampleFileMutation represents an operation that mutates the SampleFile nodes in the graph.
type SampleFileMutation struct {
	config
	op            Op
	typ           string
	id            *uint8
	_type         *string
	is_disabled   *bool
	created_time  *time.Time
	deleted_time  *time.Time
	modified_time *time.Time
	clearedFields map[string]struct{}
	file          *uint32
	clearedfile   bool
	done          bool
	oldValue      func(context.Context) (*SampleFile, error)
	predicates    []predicate.SampleFile
}

var _ ent.Mutation = (*SampleFileMutation)(nil)

// samplefileOption allows management of the mutation configuration using functional options.
type samplefileOption func(*SampleFileMutation)

// newSampleFileMutation creates new mutation for the SampleFile entity.
func newSampleFileMutation(c config, op Op, opts ...samplefileOption) *SampleFileMutation {
	m := &SampleFileMutation{
		config:        c,
		op:            op,
		typ:           TypeSampleFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSampleFileID sets the ID field of the mutation.
func withSampleFileID(id uint8) samplefileOption {
	return func(m *SampleFileMutation) {
		var (
			err   error
			once  sync.Once
			value *SampleFile
		)
		m.oldValue = func(ctx context.Context) (*SampleFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SampleFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSampleFile sets the old SampleFile of the mutation.
func withSampleFile(node *SampleFile) samplefileOption {
	return func(m *SampleFileMutation) {
		m.oldValue = func(context.Context) (*SampleFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SampleFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SampleFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SampleFile entities.
func (m *SampleFileMutation) SetID(id uint8) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SampleFileMutation) ID() (id uint8, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SampleFileMutation) IDs(ctx context.Context) ([]uint8, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint8{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SampleFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFid sets the "fid" field.
func (m *SampleFileMutation) SetFid(u uint32) {
	m.file = &u
}

// Fid returns the value of the "fid" field in the mutation.
func (m *SampleFileMutation) Fid() (r uint32, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFid returns the old "fid" field's value of the SampleFile entity.
// If the SampleFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleFileMutation) OldFid(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFid: %w", err)
	}
	return oldValue.Fid, nil
}

// ResetFid resets all changes to the "fid" field.
func (m *SampleFileMutation) ResetFid() {
	m.file = nil
}

// SetType sets the "type" field.
func (m *SampleFileMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SampleFileMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SampleFile entity.
// If the SampleFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleFileMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SampleFileMutation) ResetType() {
	m._type = nil
}

// SetIsDisabled sets the "is_disabled" field.
func (m *SampleFileMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *SampleFileMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the SampleFile entity.
// If the SampleFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleFileMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *SampleFileMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *SampleFileMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *SampleFileMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the SampleFile entity.
// If the SampleFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleFileMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *SampleFileMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *SampleFileMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *SampleFileMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the SampleFile entity.
// If the SampleFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleFileMutation) OldDeletedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ClearDeletedTime clears the value of the "deleted_time" field.
func (m *SampleFileMutation) ClearDeletedTime() {
	m.deleted_time = nil
	m.clearedFields[samplefile.FieldDeletedTime] = struct{}{}
}

// DeletedTimeCleared returns if the "deleted_time" field was cleared in this mutation.
func (m *SampleFileMutation) DeletedTimeCleared() bool {
	_, ok := m.clearedFields[samplefile.FieldDeletedTime]
	return ok
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *SampleFileMutation) ResetDeletedTime() {
	m.deleted_time = nil
	delete(m.clearedFields, samplefile.FieldDeletedTime)
}

// SetModifiedTime sets the "modified_time" field.
func (m *SampleFileMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *SampleFileMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the SampleFile entity.
// If the SampleFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleFileMutation) OldModifiedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ClearModifiedTime clears the value of the "modified_time" field.
func (m *SampleFileMutation) ClearModifiedTime() {
	m.modified_time = nil
	m.clearedFields[samplefile.FieldModifiedTime] = struct{}{}
}

// ModifiedTimeCleared returns if the "modified_time" field was cleared in this mutation.
func (m *SampleFileMutation) ModifiedTimeCleared() bool {
	_, ok := m.clearedFields[samplefile.FieldModifiedTime]
	return ok
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *SampleFileMutation) ResetModifiedTime() {
	m.modified_time = nil
	delete(m.clearedFields, samplefile.FieldModifiedTime)
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *SampleFileMutation) SetFileID(id uint32) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *SampleFileMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *SampleFileMutation) FileCleared() bool {
	return m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *SampleFileMutation) FileID() (id uint32, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *SampleFileMutation) FileIDs() (ids []uint32) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *SampleFileMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// Where appends a list predicates to the SampleFileMutation builder.
func (m *SampleFileMutation) Where(ps ...predicate.SampleFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SampleFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SampleFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SampleFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SampleFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SampleFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SampleFile).
func (m *SampleFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SampleFileMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.file != nil {
		fields = append(fields, samplefile.FieldFid)
	}
	if m._type != nil {
		fields = append(fields, samplefile.FieldType)
	}
	if m.is_disabled != nil {
		fields = append(fields, samplefile.FieldIsDisabled)
	}
	if m.created_time != nil {
		fields = append(fields, samplefile.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, samplefile.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, samplefile.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SampleFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case samplefile.FieldFid:
		return m.Fid()
	case samplefile.FieldType:
		return m.GetType()
	case samplefile.FieldIsDisabled:
		return m.IsDisabled()
	case samplefile.FieldCreatedTime:
		return m.CreatedTime()
	case samplefile.FieldDeletedTime:
		return m.DeletedTime()
	case samplefile.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SampleFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case samplefile.FieldFid:
		return m.OldFid(ctx)
	case samplefile.FieldType:
		return m.OldType(ctx)
	case samplefile.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case samplefile.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case samplefile.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case samplefile.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown SampleFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SampleFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case samplefile.FieldFid:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFid(v)
		return nil
	case samplefile.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case samplefile.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case samplefile.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case samplefile.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case samplefile.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown SampleFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SampleFileMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SampleFileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SampleFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SampleFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SampleFileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(samplefile.FieldDeletedTime) {
		fields = append(fields, samplefile.FieldDeletedTime)
	}
	if m.FieldCleared(samplefile.FieldModifiedTime) {
		fields = append(fields, samplefile.FieldModifiedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SampleFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SampleFileMutation) ClearField(name string) error {
	switch name {
	case samplefile.FieldDeletedTime:
		m.ClearDeletedTime()
		return nil
	case samplefile.FieldModifiedTime:
		m.ClearModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown SampleFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SampleFileMutation) ResetField(name string) error {
	switch name {
	case samplefile.FieldFid:
		m.ResetFid()
		return nil
	case samplefile.FieldType:
		m.ResetType()
		return nil
	case samplefile.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case samplefile.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case samplefile.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case samplefile.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown SampleFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SampleFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.file != nil {
		edges = append(edges, samplefile.EdgeFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SampleFileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case samplefile.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SampleFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SampleFileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SampleFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfile {
		edges = append(edges, samplefile.EdgeFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SampleFileMutation) EdgeCleared(name string) bool {
	switch name {
	case samplefile.EdgeFile:
		return m.clearedfile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SampleFileMutation) ClearEdge(name string) error {
	switch name {
	case samplefile.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown SampleFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SampleFileMutation) ResetEdge(name string) error {
	switch name {
	case samplefile.EdgeFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown SampleFile edge %s", name)
}

// SchoolMutation represents an operation that mutates the School nodes in the graph.
type SchoolMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint16
	code                 *string
	name                 *string
	location             *string
	competent_department *string
	education_level      *uint8
	addeducation_level   *int8
	remark               *string
	is_disabled          *bool
	created_time         *time.Time
	deleted_time         *time.Time
	modified_time        *time.Time
	clearedFields        map[string]struct{}
	colleges             map[uint16]struct{}
	removedcolleges      map[uint16]struct{}
	clearedcolleges      bool
	done                 bool
	oldValue             func(context.Context) (*School, error)
	predicates           []predicate.School
}

var _ ent.Mutation = (*SchoolMutation)(nil)

// schoolOption allows management of the mutation configuration using functional options.
type schoolOption func(*SchoolMutation)

// newSchoolMutation creates new mutation for the School entity.
func newSchoolMutation(c config, op Op, opts ...schoolOption) *SchoolMutation {
	m := &SchoolMutation{
		config:        c,
		op:            op,
		typ:           TypeSchool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSchoolID sets the ID field of the mutation.
func withSchoolID(id uint16) schoolOption {
	return func(m *SchoolMutation) {
		var (
			err   error
			once  sync.Once
			value *School
		)
		m.oldValue = func(ctx context.Context) (*School, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().School.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchool sets the old School of the mutation.
func withSchool(node *School) schoolOption {
	return func(m *SchoolMutation) {
		m.oldValue = func(context.Context) (*School, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SchoolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SchoolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of School entities.
func (m *SchoolMutation) SetID(id uint16) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SchoolMutation) ID() (id uint16, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SchoolMutation) IDs(ctx context.Context) ([]uint16, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint16{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().School.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *SchoolMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *SchoolMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *SchoolMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *SchoolMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SchoolMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SchoolMutation) ResetName() {
	m.name = nil
}

// SetLocation sets the "location" field.
func (m *SchoolMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *SchoolMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *SchoolMutation) ResetLocation() {
	m.location = nil
}

// SetCompetentDepartment sets the "competent_department" field.
func (m *SchoolMutation) SetCompetentDepartment(s string) {
	m.competent_department = &s
}

// CompetentDepartment returns the value of the "competent_department" field in the mutation.
func (m *SchoolMutation) CompetentDepartment() (r string, exists bool) {
	v := m.competent_department
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetentDepartment returns the old "competent_department" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldCompetentDepartment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetentDepartment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetentDepartment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetentDepartment: %w", err)
	}
	return oldValue.CompetentDepartment, nil
}

// ResetCompetentDepartment resets all changes to the "competent_department" field.
func (m *SchoolMutation) ResetCompetentDepartment() {
	m.competent_department = nil
}

// SetEducationLevel sets the "education_level" field.
func (m *SchoolMutation) SetEducationLevel(u uint8) {
	m.education_level = &u
	m.addeducation_level = nil
}

// EducationLevel returns the value of the "education_level" field in the mutation.
func (m *SchoolMutation) EducationLevel() (r uint8, exists bool) {
	v := m.education_level
	if v == nil {
		return
	}
	return *v, true
}

// OldEducationLevel returns the old "education_level" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldEducationLevel(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEducationLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEducationLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducationLevel: %w", err)
	}
	return oldValue.EducationLevel, nil
}

// AddEducationLevel adds u to the "education_level" field.
func (m *SchoolMutation) AddEducationLevel(u int8) {
	if m.addeducation_level != nil {
		*m.addeducation_level += u
	} else {
		m.addeducation_level = &u
	}
}

// AddedEducationLevel returns the value that was added to the "education_level" field in this mutation.
func (m *SchoolMutation) AddedEducationLevel() (r int8, exists bool) {
	v := m.addeducation_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetEducationLevel resets all changes to the "education_level" field.
func (m *SchoolMutation) ResetEducationLevel() {
	m.education_level = nil
	m.addeducation_level = nil
}

// SetRemark sets the "remark" field.
func (m *SchoolMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *SchoolMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *SchoolMutation) ResetRemark() {
	m.remark = nil
}

// SetIsDisabled sets the "is_disabled" field.
func (m *SchoolMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *SchoolMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *SchoolMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *SchoolMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *SchoolMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *SchoolMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *SchoolMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *SchoolMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldDeletedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *SchoolMutation) ResetDeletedTime() {
	m.deleted_time = nil
}

// SetModifiedTime sets the "modified_time" field.
func (m *SchoolMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *SchoolMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldModifiedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *SchoolMutation) ResetModifiedTime() {
	m.modified_time = nil
}

// AddCollegeIDs adds the "colleges" edge to the College entity by ids.
func (m *SchoolMutation) AddCollegeIDs(ids ...uint16) {
	if m.colleges == nil {
		m.colleges = make(map[uint16]struct{})
	}
	for i := range ids {
		m.colleges[ids[i]] = struct{}{}
	}
}

// ClearColleges clears the "colleges" edge to the College entity.
func (m *SchoolMutation) ClearColleges() {
	m.clearedcolleges = true
}

// CollegesCleared reports if the "colleges" edge to the College entity was cleared.
func (m *SchoolMutation) CollegesCleared() bool {
	return m.clearedcolleges
}

// RemoveCollegeIDs removes the "colleges" edge to the College entity by IDs.
func (m *SchoolMutation) RemoveCollegeIDs(ids ...uint16) {
	if m.removedcolleges == nil {
		m.removedcolleges = make(map[uint16]struct{})
	}
	for i := range ids {
		delete(m.colleges, ids[i])
		m.removedcolleges[ids[i]] = struct{}{}
	}
}

// RemovedColleges returns the removed IDs of the "colleges" edge to the College entity.
func (m *SchoolMutation) RemovedCollegesIDs() (ids []uint16) {
	for id := range m.removedcolleges {
		ids = append(ids, id)
	}
	return
}

// CollegesIDs returns the "colleges" edge IDs in the mutation.
func (m *SchoolMutation) CollegesIDs() (ids []uint16) {
	for id := range m.colleges {
		ids = append(ids, id)
	}
	return
}

// ResetColleges resets all changes to the "colleges" edge.
func (m *SchoolMutation) ResetColleges() {
	m.colleges = nil
	m.clearedcolleges = false
	m.removedcolleges = nil
}

// Where appends a list predicates to the SchoolMutation builder.
func (m *SchoolMutation) Where(ps ...predicate.School) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SchoolMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SchoolMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.School, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SchoolMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SchoolMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (School).
func (m *SchoolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SchoolMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.code != nil {
		fields = append(fields, school.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, school.FieldName)
	}
	if m.location != nil {
		fields = append(fields, school.FieldLocation)
	}
	if m.competent_department != nil {
		fields = append(fields, school.FieldCompetentDepartment)
	}
	if m.education_level != nil {
		fields = append(fields, school.FieldEducationLevel)
	}
	if m.remark != nil {
		fields = append(fields, school.FieldRemark)
	}
	if m.is_disabled != nil {
		fields = append(fields, school.FieldIsDisabled)
	}
	if m.created_time != nil {
		fields = append(fields, school.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, school.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, school.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SchoolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case school.FieldCode:
		return m.Code()
	case school.FieldName:
		return m.Name()
	case school.FieldLocation:
		return m.Location()
	case school.FieldCompetentDepartment:
		return m.CompetentDepartment()
	case school.FieldEducationLevel:
		return m.EducationLevel()
	case school.FieldRemark:
		return m.Remark()
	case school.FieldIsDisabled:
		return m.IsDisabled()
	case school.FieldCreatedTime:
		return m.CreatedTime()
	case school.FieldDeletedTime:
		return m.DeletedTime()
	case school.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SchoolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case school.FieldCode:
		return m.OldCode(ctx)
	case school.FieldName:
		return m.OldName(ctx)
	case school.FieldLocation:
		return m.OldLocation(ctx)
	case school.FieldCompetentDepartment:
		return m.OldCompetentDepartment(ctx)
	case school.FieldEducationLevel:
		return m.OldEducationLevel(ctx)
	case school.FieldRemark:
		return m.OldRemark(ctx)
	case school.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case school.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case school.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case school.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown School field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchoolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case school.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case school.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case school.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case school.FieldCompetentDepartment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetentDepartment(v)
		return nil
	case school.FieldEducationLevel:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducationLevel(v)
		return nil
	case school.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case school.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case school.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case school.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case school.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown School field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SchoolMutation) AddedFields() []string {
	var fields []string
	if m.addeducation_level != nil {
		fields = append(fields, school.FieldEducationLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SchoolMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case school.FieldEducationLevel:
		return m.AddedEducationLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchoolMutation) AddField(name string, value ent.Value) error {
	switch name {
	case school.FieldEducationLevel:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEducationLevel(v)
		return nil
	}
	return fmt.Errorf("unknown School numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SchoolMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SchoolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SchoolMutation) ClearField(name string) error {
	return fmt.Errorf("unknown School nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SchoolMutation) ResetField(name string) error {
	switch name {
	case school.FieldCode:
		m.ResetCode()
		return nil
	case school.FieldName:
		m.ResetName()
		return nil
	case school.FieldLocation:
		m.ResetLocation()
		return nil
	case school.FieldCompetentDepartment:
		m.ResetCompetentDepartment()
		return nil
	case school.FieldEducationLevel:
		m.ResetEducationLevel()
		return nil
	case school.FieldRemark:
		m.ResetRemark()
		return nil
	case school.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case school.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case school.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case school.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown School field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SchoolMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.colleges != nil {
		edges = append(edges, school.EdgeColleges)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SchoolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case school.EdgeColleges:
		ids := make([]ent.Value, 0, len(m.colleges))
		for id := range m.colleges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SchoolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcolleges != nil {
		edges = append(edges, school.EdgeColleges)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SchoolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case school.EdgeColleges:
		ids := make([]ent.Value, 0, len(m.removedcolleges))
		for id := range m.removedcolleges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SchoolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcolleges {
		edges = append(edges, school.EdgeColleges)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SchoolMutation) EdgeCleared(name string) bool {
	switch name {
	case school.EdgeColleges:
		return m.clearedcolleges
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SchoolMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown School unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SchoolMutation) ResetEdge(name string) error {
	switch name {
	case school.EdgeColleges:
		m.ResetColleges()
		return nil
	}
	return fmt.Errorf("unknown School edge %s", name)
}

// StudentMutation represents an operation that mutates the Student nodes in the graph.
type StudentMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	student_id     *string
	name           *string
	gender         *uint8
	addgender      *int8
	birthday       *time.Time
	admission_date *time.Time
	state          *uint8
	addstate       *int8
	is_disabled    *bool
	created_time   *time.Time
	deleted_time   *time.Time
	modified_time  *time.Time
	clearedFields  map[string]struct{}
	class          *uint32
	clearedclass   bool
	user           *uint32
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Student, error)
	predicates     []predicate.Student
}

var _ ent.Mutation = (*StudentMutation)(nil)

// studentOption allows management of the mutation configuration using functional options.
type studentOption func(*StudentMutation)

// newStudentMutation creates new mutation for the Student entity.
func newStudentMutation(c config, op Op, opts ...studentOption) *StudentMutation {
	m := &StudentMutation{
		config:        c,
		op:            op,
		typ:           TypeStudent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStudentID sets the ID field of the mutation.
func withStudentID(id uint32) studentOption {
	return func(m *StudentMutation) {
		var (
			err   error
			once  sync.Once
			value *Student
		)
		m.oldValue = func(ctx context.Context) (*Student, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Student.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStudent sets the old Student of the mutation.
func withStudent(node *Student) studentOption {
	return func(m *StudentMutation) {
		m.oldValue = func(context.Context) (*Student, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StudentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StudentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Student entities.
func (m *StudentMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StudentMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StudentMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Student.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *StudentMutation) SetUID(u uint32) {
	m.user = &u
}

// UID returns the value of the "uid" field in the mutation.
func (m *StudentMutation) UID() (r uint32, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldUID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *StudentMutation) ResetUID() {
	m.user = nil
}

// SetCid sets the "cid" field.
func (m *StudentMutation) SetCid(u uint32) {
	m.class = &u
}

// Cid returns the value of the "cid" field in the mutation.
func (m *StudentMutation) Cid() (r uint32, exists bool) {
	v := m.class
	if v == nil {
		return
	}
	return *v, true
}

// OldCid returns the old "cid" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldCid(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCid: %w", err)
	}
	return oldValue.Cid, nil
}

// ResetCid resets all changes to the "cid" field.
func (m *StudentMutation) ResetCid() {
	m.class = nil
}

// SetStudentID sets the "student_id" field.
func (m *StudentMutation) SetStudentID(s string) {
	m.student_id = &s
}

// StudentID returns the value of the "student_id" field in the mutation.
func (m *StudentMutation) StudentID() (r string, exists bool) {
	v := m.student_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStudentID returns the old "student_id" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldStudentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStudentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStudentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStudentID: %w", err)
	}
	return oldValue.StudentID, nil
}

// ResetStudentID resets all changes to the "student_id" field.
func (m *StudentMutation) ResetStudentID() {
	m.student_id = nil
}

// SetName sets the "name" field.
func (m *StudentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StudentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StudentMutation) ResetName() {
	m.name = nil
}

// SetGender sets the "gender" field.
func (m *StudentMutation) SetGender(u uint8) {
	m.gender = &u
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *StudentMutation) Gender() (r uint8, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldGender(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds u to the "gender" field.
func (m *StudentMutation) AddGender(u int8) {
	if m.addgender != nil {
		*m.addgender += u
	} else {
		m.addgender = &u
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *StudentMutation) AddedGender() (r int8, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ResetGender resets all changes to the "gender" field.
func (m *StudentMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
}

// SetBirthday sets the "birthday" field.
func (m *StudentMutation) SetBirthday(t time.Time) {
	m.birthday = &t
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *StudentMutation) Birthday() (r time.Time, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldBirthday(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *StudentMutation) ResetBirthday() {
	m.birthday = nil
}

// SetAdmissionDate sets the "admission_date" field.
func (m *StudentMutation) SetAdmissionDate(t time.Time) {
	m.admission_date = &t
}

// AdmissionDate returns the value of the "admission_date" field in the mutation.
func (m *StudentMutation) AdmissionDate() (r time.Time, exists bool) {
	v := m.admission_date
	if v == nil {
		return
	}
	return *v, true
}

// OldAdmissionDate returns the old "admission_date" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldAdmissionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdmissionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdmissionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdmissionDate: %w", err)
	}
	return oldValue.AdmissionDate, nil
}

// ResetAdmissionDate resets all changes to the "admission_date" field.
func (m *StudentMutation) ResetAdmissionDate() {
	m.admission_date = nil
}

// SetState sets the "state" field.
func (m *StudentMutation) SetState(u uint8) {
	m.state = &u
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *StudentMutation) State() (r uint8, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldState(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds u to the "state" field.
func (m *StudentMutation) AddState(u int8) {
	if m.addstate != nil {
		*m.addstate += u
	} else {
		m.addstate = &u
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *StudentMutation) AddedState() (r int8, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *StudentMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetIsDisabled sets the "is_disabled" field.
func (m *StudentMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *StudentMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *StudentMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *StudentMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *StudentMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *StudentMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *StudentMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *StudentMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldDeletedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *StudentMutation) ResetDeletedTime() {
	m.deleted_time = nil
}

// SetModifiedTime sets the "modified_time" field.
func (m *StudentMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *StudentMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldModifiedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *StudentMutation) ResetModifiedTime() {
	m.modified_time = nil
}

// SetClassID sets the "class" edge to the Class entity by id.
func (m *StudentMutation) SetClassID(id uint32) {
	m.class = &id
}

// ClearClass clears the "class" edge to the Class entity.
func (m *StudentMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *StudentMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *StudentMutation) ClassID() (id uint32, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) ClassIDs() (ids []uint32) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *StudentMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *StudentMutation) SetUserID(id uint32) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *StudentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *StudentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *StudentMutation) UserID() (id uint32, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) UserIDs() (ids []uint32) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *StudentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the StudentMutation builder.
func (m *StudentMutation) Where(ps ...predicate.Student) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StudentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StudentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Student, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StudentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StudentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Student).
func (m *StudentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StudentMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.user != nil {
		fields = append(fields, student.FieldUID)
	}
	if m.class != nil {
		fields = append(fields, student.FieldCid)
	}
	if m.student_id != nil {
		fields = append(fields, student.FieldStudentID)
	}
	if m.name != nil {
		fields = append(fields, student.FieldName)
	}
	if m.gender != nil {
		fields = append(fields, student.FieldGender)
	}
	if m.birthday != nil {
		fields = append(fields, student.FieldBirthday)
	}
	if m.admission_date != nil {
		fields = append(fields, student.FieldAdmissionDate)
	}
	if m.state != nil {
		fields = append(fields, student.FieldState)
	}
	if m.is_disabled != nil {
		fields = append(fields, student.FieldIsDisabled)
	}
	if m.created_time != nil {
		fields = append(fields, student.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, student.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, student.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StudentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case student.FieldUID:
		return m.UID()
	case student.FieldCid:
		return m.Cid()
	case student.FieldStudentID:
		return m.StudentID()
	case student.FieldName:
		return m.Name()
	case student.FieldGender:
		return m.Gender()
	case student.FieldBirthday:
		return m.Birthday()
	case student.FieldAdmissionDate:
		return m.AdmissionDate()
	case student.FieldState:
		return m.State()
	case student.FieldIsDisabled:
		return m.IsDisabled()
	case student.FieldCreatedTime:
		return m.CreatedTime()
	case student.FieldDeletedTime:
		return m.DeletedTime()
	case student.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StudentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case student.FieldUID:
		return m.OldUID(ctx)
	case student.FieldCid:
		return m.OldCid(ctx)
	case student.FieldStudentID:
		return m.OldStudentID(ctx)
	case student.FieldName:
		return m.OldName(ctx)
	case student.FieldGender:
		return m.OldGender(ctx)
	case student.FieldBirthday:
		return m.OldBirthday(ctx)
	case student.FieldAdmissionDate:
		return m.OldAdmissionDate(ctx)
	case student.FieldState:
		return m.OldState(ctx)
	case student.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case student.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case student.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case student.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Student field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case student.FieldUID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case student.FieldCid:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCid(v)
		return nil
	case student.FieldStudentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStudentID(v)
		return nil
	case student.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case student.FieldGender:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case student.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case student.FieldAdmissionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdmissionDate(v)
		return nil
	case student.FieldState:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case student.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case student.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case student.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case student.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StudentMutation) AddedFields() []string {
	var fields []string
	if m.addgender != nil {
		fields = append(fields, student.FieldGender)
	}
	if m.addstate != nil {
		fields = append(fields, student.FieldState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StudentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case student.FieldGender:
		return m.AddedGender()
	case student.FieldState:
		return m.AddedState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case student.FieldGender:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	case student.FieldState:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	}
	return fmt.Errorf("unknown Student numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StudentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StudentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StudentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Student nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StudentMutation) ResetField(name string) error {
	switch name {
	case student.FieldUID:
		m.ResetUID()
		return nil
	case student.FieldCid:
		m.ResetCid()
		return nil
	case student.FieldStudentID:
		m.ResetStudentID()
		return nil
	case student.FieldName:
		m.ResetName()
		return nil
	case student.FieldGender:
		m.ResetGender()
		return nil
	case student.FieldBirthday:
		m.ResetBirthday()
		return nil
	case student.FieldAdmissionDate:
		m.ResetAdmissionDate()
		return nil
	case student.FieldState:
		m.ResetState()
		return nil
	case student.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case student.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case student.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case student.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StudentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.class != nil {
		edges = append(edges, student.EdgeClass)
	}
	if m.user != nil {
		edges = append(edges, student.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StudentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	case student.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StudentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StudentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StudentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedclass {
		edges = append(edges, student.EdgeClass)
	}
	if m.cleareduser {
		edges = append(edges, student.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StudentMutation) EdgeCleared(name string) bool {
	switch name {
	case student.EdgeClass:
		return m.clearedclass
	case student.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StudentMutation) ClearEdge(name string) error {
	switch name {
	case student.EdgeClass:
		m.ClearClass()
		return nil
	case student.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Student unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StudentMutation) ResetEdge(name string) error {
	switch name {
	case student.EdgeClass:
		m.ResetClass()
		return nil
	case student.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Student edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	account         *string
	password        *string
	username        *string
	email           *string
	phone           *string
	introduction    *string
	is_disabled     *bool
	created_time    *time.Time
	deleted_time    *time.Time
	modified_time   *time.Time
	clearedFields   map[string]struct{}
	roles           map[uint8]struct{}
	removedroles    map[uint8]struct{}
	clearedroles    bool
	students        map[uint32]struct{}
	removedstudents map[uint32]struct{}
	clearedstudents bool
	files           map[uint32]struct{}
	removedfiles    map[uint32]struct{}
	clearedfiles    bool
	done            bool
	oldValue        func(context.Context) (*User, error)
	predicates      []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uint32) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAccount sets the "account" field.
func (m *UserMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *UserMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *UserMutation) ResetAccount() {
	m.account = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *UserMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[user.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *UserMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[user.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, user.FieldUsername)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetIntroduction sets the "introduction" field.
func (m *UserMutation) SetIntroduction(s string) {
	m.introduction = &s
}

// Introduction returns the value of the "introduction" field in the mutation.
func (m *UserMutation) Introduction() (r string, exists bool) {
	v := m.introduction
	if v == nil {
		return
	}
	return *v, true
}

// OldIntroduction returns the old "introduction" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIntroduction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntroduction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntroduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntroduction: %w", err)
	}
	return oldValue.Introduction, nil
}

// ClearIntroduction clears the value of the "introduction" field.
func (m *UserMutation) ClearIntroduction() {
	m.introduction = nil
	m.clearedFields[user.FieldIntroduction] = struct{}{}
}

// IntroductionCleared returns if the "introduction" field was cleared in this mutation.
func (m *UserMutation) IntroductionCleared() bool {
	_, ok := m.clearedFields[user.FieldIntroduction]
	return ok
}

// ResetIntroduction resets all changes to the "introduction" field.
func (m *UserMutation) ResetIntroduction() {
	m.introduction = nil
	delete(m.clearedFields, user.FieldIntroduction)
}

// SetIsDisabled sets the "is_disabled" field.
func (m *UserMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *UserMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *UserMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *UserMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *UserMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *UserMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetDeletedTime sets the "deleted_time" field.
func (m *UserMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *UserMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ClearDeletedTime clears the value of the "deleted_time" field.
func (m *UserMutation) ClearDeletedTime() {
	m.deleted_time = nil
	m.clearedFields[user.FieldDeletedTime] = struct{}{}
}

// DeletedTimeCleared returns if the "deleted_time" field was cleared in this mutation.
func (m *UserMutation) DeletedTimeCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedTime]
	return ok
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *UserMutation) ResetDeletedTime() {
	m.deleted_time = nil
	delete(m.clearedFields, user.FieldDeletedTime)
}

// SetModifiedTime sets the "modified_time" field.
func (m *UserMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *UserMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldModifiedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ClearModifiedTime clears the value of the "modified_time" field.
func (m *UserMutation) ClearModifiedTime() {
	m.modified_time = nil
	m.clearedFields[user.FieldModifiedTime] = struct{}{}
}

// ModifiedTimeCleared returns if the "modified_time" field was cleared in this mutation.
func (m *UserMutation) ModifiedTimeCleared() bool {
	_, ok := m.clearedFields[user.FieldModifiedTime]
	return ok
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *UserMutation) ResetModifiedTime() {
	m.modified_time = nil
	delete(m.clearedFields, user.FieldModifiedTime)
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *UserMutation) AddRoleIDs(ids ...uint8) {
	if m.roles == nil {
		m.roles = make(map[uint8]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *UserMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *UserMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *UserMutation) RemoveRoleIDs(ids ...uint8) {
	if m.removedroles == nil {
		m.removedroles = make(map[uint8]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *UserMutation) RemovedRolesIDs() (ids []uint8) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *UserMutation) RolesIDs() (ids []uint8) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddStudentIDs adds the "students" edge to the Student entity by ids.
func (m *UserMutation) AddStudentIDs(ids ...uint32) {
	if m.students == nil {
		m.students = make(map[uint32]struct{})
	}
	for i := range ids {
		m.students[ids[i]] = struct{}{}
	}
}

// ClearStudents clears the "students" edge to the Student entity.
func (m *UserMutation) ClearStudents() {
	m.clearedstudents = true
}

// StudentsCleared reports if the "students" edge to the Student entity was cleared.
func (m *UserMutation) StudentsCleared() bool {
	return m.clearedstudents
}

// RemoveStudentIDs removes the "students" edge to the Student entity by IDs.
func (m *UserMutation) RemoveStudentIDs(ids ...uint32) {
	if m.removedstudents == nil {
		m.removedstudents = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.students, ids[i])
		m.removedstudents[ids[i]] = struct{}{}
	}
}

// RemovedStudents returns the removed IDs of the "students" edge to the Student entity.
func (m *UserMutation) RemovedStudentsIDs() (ids []uint32) {
	for id := range m.removedstudents {
		ids = append(ids, id)
	}
	return
}

// StudentsIDs returns the "students" edge IDs in the mutation.
func (m *UserMutation) StudentsIDs() (ids []uint32) {
	for id := range m.students {
		ids = append(ids, id)
	}
	return
}

// ResetStudents resets all changes to the "students" edge.
func (m *UserMutation) ResetStudents() {
	m.students = nil
	m.clearedstudents = false
	m.removedstudents = nil
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *UserMutation) AddFileIDs(ids ...uint32) {
	if m.files == nil {
		m.files = make(map[uint32]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *UserMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *UserMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *UserMutation) RemoveFileIDs(ids ...uint32) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *UserMutation) RemovedFilesIDs() (ids []uint32) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *UserMutation) FilesIDs() (ids []uint32) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *UserMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.account != nil {
		fields = append(fields, user.FieldAccount)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.introduction != nil {
		fields = append(fields, user.FieldIntroduction)
	}
	if m.is_disabled != nil {
		fields = append(fields, user.FieldIsDisabled)
	}
	if m.created_time != nil {
		fields = append(fields, user.FieldCreatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, user.FieldDeletedTime)
	}
	if m.modified_time != nil {
		fields = append(fields, user.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldAccount:
		return m.Account()
	case user.FieldPassword:
		return m.Password()
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldIntroduction:
		return m.Introduction()
	case user.FieldIsDisabled:
		return m.IsDisabled()
	case user.FieldCreatedTime:
		return m.CreatedTime()
	case user.FieldDeletedTime:
		return m.DeletedTime()
	case user.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldAccount:
		return m.OldAccount(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldIntroduction:
		return m.OldIntroduction(ctx)
	case user.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case user.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case user.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case user.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldIntroduction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntroduction(v)
		return nil
	case user.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case user.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case user.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case user.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldUsername) {
		fields = append(fields, user.FieldUsername)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	if m.FieldCleared(user.FieldIntroduction) {
		fields = append(fields, user.FieldIntroduction)
	}
	if m.FieldCleared(user.FieldDeletedTime) {
		fields = append(fields, user.FieldDeletedTime)
	}
	if m.FieldCleared(user.FieldModifiedTime) {
		fields = append(fields, user.FieldModifiedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ClearUsername()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	case user.FieldIntroduction:
		m.ClearIntroduction()
		return nil
	case user.FieldDeletedTime:
		m.ClearDeletedTime()
		return nil
	case user.FieldModifiedTime:
		m.ClearModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldAccount:
		m.ResetAccount()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldIntroduction:
		m.ResetIntroduction()
		return nil
	case user.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case user.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case user.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case user.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.roles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.students != nil {
		edges = append(edges, user.EdgeStudents)
	}
	if m.files != nil {
		edges = append(edges, user.EdgeFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeStudents:
		ids := make([]ent.Value, 0, len(m.students))
		for id := range m.students {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedroles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.removedstudents != nil {
		edges = append(edges, user.EdgeStudents)
	}
	if m.removedfiles != nil {
		edges = append(edges, user.EdgeFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeStudents:
		ids := make([]ent.Value, 0, len(m.removedstudents))
		for id := range m.removedstudents {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedroles {
		edges = append(edges, user.EdgeRoles)
	}
	if m.clearedstudents {
		edges = append(edges, user.EdgeStudents)
	}
	if m.clearedfiles {
		edges = append(edges, user.EdgeFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRoles:
		return m.clearedroles
	case user.EdgeStudents:
		return m.clearedstudents
	case user.EdgeFiles:
		return m.clearedfiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeRoles:
		m.ResetRoles()
		return nil
	case user.EdgeStudents:
		m.ResetStudents()
		return nil
	case user.EdgeFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserRoleMutation represents an operation that mutates the UserRole nodes in the graph.
type UserRoleMutation struct {
	config
	op            Op
	typ           string
	created_time  *time.Time
	clearedFields map[string]struct{}
	user          *uint32
	cleareduser   bool
	role          *uint8
	clearedrole   bool
	done          bool
	oldValue      func(context.Context) (*UserRole, error)
	predicates    []predicate.UserRole
}

var _ ent.Mutation = (*UserRoleMutation)(nil)

// userroleOption allows management of the mutation configuration using functional options.
type userroleOption func(*UserRoleMutation)

// newUserRoleMutation creates new mutation for the UserRole entity.
func newUserRoleMutation(c config, op Op, opts ...userroleOption) *UserRoleMutation {
	m := &UserRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeUserRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUID sets the "uid" field.
func (m *UserRoleMutation) SetUID(u uint32) {
	m.user = &u
}

// UID returns the value of the "uid" field in the mutation.
func (m *UserRoleMutation) UID() (r uint32, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUID resets all changes to the "uid" field.
func (m *UserRoleMutation) ResetUID() {
	m.user = nil
}

// SetRid sets the "rid" field.
func (m *UserRoleMutation) SetRid(u uint8) {
	m.role = &u
}

// Rid returns the value of the "rid" field in the mutation.
func (m *UserRoleMutation) Rid() (r uint8, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// ResetRid resets all changes to the "rid" field.
func (m *UserRoleMutation) ResetRid() {
	m.role = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *UserRoleMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *UserRoleMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *UserRoleMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserRoleMutation) SetUserID(id uint32) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserRoleMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserRoleMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserRoleMutation) UserID() (id uint32, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) UserIDs() (ids []uint32) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserRoleMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetRoleID sets the "role" edge to the Role entity by id.
func (m *UserRoleMutation) SetRoleID(id uint8) {
	m.role = &id
}

// ClearRole clears the "role" edge to the Role entity.
func (m *UserRoleMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *UserRoleMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleID returns the "role" edge ID in the mutation.
func (m *UserRoleMutation) RoleID() (id uint8, exists bool) {
	if m.role != nil {
		return *m.role, true
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) RoleIDs() (ids []uint8) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *UserRoleMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the UserRoleMutation builder.
func (m *UserRoleMutation) Where(ps ...predicate.UserRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserRole).
func (m *UserRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserRoleMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, userrole.FieldUID)
	}
	if m.role != nil {
		fields = append(fields, userrole.FieldRid)
	}
	if m.created_time != nil {
		fields = append(fields, userrole.FieldCreatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldUID:
		return m.UID()
	case userrole.FieldRid:
		return m.Rid()
	case userrole.FieldCreatedTime:
		return m.CreatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserRole does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldUID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case userrole.FieldRid:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRid(v)
		return nil
	case userrole.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserRoleMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserRoleMutation) ResetField(name string) error {
	switch name {
	case userrole.FieldUID:
		m.ResetUID()
		return nil
	case userrole.FieldRid:
		m.ResetRid()
		return nil
	case userrole.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userrole.EdgeUser)
	}
	if m.role != nil {
		edges = append(edges, userrole.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userrole.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userrole.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userrole.EdgeUser)
	}
	if m.clearedrole {
		edges = append(edges, userrole.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case userrole.EdgeUser:
		return m.cleareduser
	case userrole.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserRoleMutation) ClearEdge(name string) error {
	switch name {
	case userrole.EdgeUser:
		m.ClearUser()
		return nil
	case userrole.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown UserRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserRoleMutation) ResetEdge(name string) error {
	switch name {
	case userrole.EdgeUser:
		m.ResetUser()
		return nil
	case userrole.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown UserRole edge %s", name)
}
